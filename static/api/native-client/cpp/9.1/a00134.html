<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Pivotal Gemfire Native C++ Reference: apache::geode::client::WritablePdxInstance Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pivotal Gemfire Native C++ Reference
   &#160;<span id="projectnumber">9.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00134.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">apache::geode::client::WritablePdxInstance Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> is a <a class="el" href="a00090.html">PdxInstance</a> that also supports field modification using the <a class="el" href="a00134.html#a5f7d2ea972f236160d22bf28da1c33c2">setField</a> method.  
 <a href="a00134.html#details">More...</a></p>

<p>Inherits <a class="el" href="a00090.html">apache::geode::client::PdxInstance</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a748e22c93c5191d62b4109b3a4a2ea22"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>classId</b> () const </td></tr>
<tr class="memdesc:a748e22c93c5191d62b4109b3a4a2ea22"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the classId of the instance being serialized.  <a href="#a748e22c93c5191d62b4109b3a4a2ea22">More...</a><br /></td></tr>
<tr class="separator:a748e22c93c5191d62b4109b3a4a2ea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1d2ba7860c5dc723e54b5f89403822"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00114.html">WritablePdxInstancePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#adf1d2ba7860c5dc723e54b5f89403822">createWriter</a> ()=0</td></tr>
<tr class="memdesc:adf1d2ba7860c5dc723e54b5f89403822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a <a class="el" href="a00134.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>.  <a href="#adf1d2ba7860c5dc723e54b5f89403822">More...</a><br /></td></tr>
<tr class="separator:adf1d2ba7860c5dc723e54b5f89403822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1182350fed20df81b0cfe45a39ffbda"><td class="memItemLeft" align="right" valign="top">virtual int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html#ad1182350fed20df81b0cfe45a39ffbda">DSFID</a> () const </td></tr>
<tr class="memdesc:ad1182350fed20df81b0cfe45a39ffbda"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the Data Serialization Fixed ID type.  <a href="#ad1182350fed20df81b0cfe45a39ffbda">More...</a><br /></td></tr>
<tr class="separator:ad1182350fed20df81b0cfe45a39ffbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68c6cbf19dec3ff13d557aa5dbf6fca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00111.html">Serializable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ad68c6cbf19dec3ff13d557aa5dbf6fca">fromData</a> (<a class="el" href="a00060.html">DataInput</a> &amp;input)</td></tr>
<tr class="memdesc:ad68c6cbf19dec3ff13d557aa5dbf6fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">deserialize this object, typical implementation should return the 'this' pointer.  <a href="#ad68c6cbf19dec3ff13d557aa5dbf6fca">More...</a><br /></td></tr>
<tr class="separator:ad68c6cbf19dec3ff13d557aa5dbf6fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ae5bd2177a88851489c3423cb28fc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aa3ae5bd2177a88851489c3423cb28fc9">fromData</a> (<a class="el" href="a00114.html">PdxReaderPtr</a> input)=0</td></tr>
<tr class="memdesc:aa3ae5bd2177a88851489c3423cb28fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialize this object.  <a href="#aa3ae5bd2177a88851489c3423cb28fc9">More...</a><br /></td></tr>
<tr class="separator:aa3ae5bd2177a88851489c3423cb28fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2bef4757b29a88942ecc027950c430d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ad2bef4757b29a88942ecc027950c430d">getClassName</a> () const  =0</td></tr>
<tr class="memdesc:ad2bef4757b29a88942ecc027950c430d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the full name of the class that this pdx instance represents.  <a href="#ad2bef4757b29a88942ecc027950c430d">More...</a><br /></td></tr>
<tr class="separator:ad2bef4757b29a88942ecc027950c430d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107b69cf82dca9eca4ad034087c294a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aa107b69cf82dca9eca4ad034087c294a">getField</a> (const char *fieldname, <a class="el" href="a00114.html">CacheablePtr</a> &amp;value) const  =0</td></tr>
<tr class="memdesc:aa107b69cf82dca9eca4ad034087c294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in CacheablePtr type out param.  <a href="#aa107b69cf82dca9eca4ad034087c294a">More...</a><br /></td></tr>
<tr class="separator:aa107b69cf82dca9eca4ad034087c294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efee322a3a99ea3407d82f952fd30e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a7efee322a3a99ea3407d82f952fd30e3">getField</a> (const char *fieldname, bool &amp;value) const  =0</td></tr>
<tr class="memdesc:a7efee322a3a99ea3407d82f952fd30e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in bool type out param.  <a href="#a7efee322a3a99ea3407d82f952fd30e3">More...</a><br /></td></tr>
<tr class="separator:a7efee322a3a99ea3407d82f952fd30e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd369059273e0bee6275a5f8252e019"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a8bd369059273e0bee6275a5f8252e019">getField</a> (const char *fieldname, signed char &amp;value) const  =0</td></tr>
<tr class="memdesc:a8bd369059273e0bee6275a5f8252e019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in signed char type out param.  <a href="#a8bd369059273e0bee6275a5f8252e019">More...</a><br /></td></tr>
<tr class="separator:a8bd369059273e0bee6275a5f8252e019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf91989aeda1b4bac7da736668c1a484"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aaf91989aeda1b4bac7da736668c1a484">getField</a> (const char *fieldname, unsigned char &amp;value) const  =0</td></tr>
<tr class="memdesc:aaf91989aeda1b4bac7da736668c1a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in unsigned char type out param.  <a href="#aaf91989aeda1b4bac7da736668c1a484">More...</a><br /></td></tr>
<tr class="separator:aaf91989aeda1b4bac7da736668c1a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00f6bf6d71914ac0fc5dcf8c88419b8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ae00f6bf6d71914ac0fc5dcf8c88419b8">getField</a> (const char *fieldname, int16_t &amp;value) const  =0</td></tr>
<tr class="memdesc:ae00f6bf6d71914ac0fc5dcf8c88419b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int16_t type out param.  <a href="#ae00f6bf6d71914ac0fc5dcf8c88419b8">More...</a><br /></td></tr>
<tr class="separator:ae00f6bf6d71914ac0fc5dcf8c88419b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fc562045bc6b2804421f36a474094a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ae2fc562045bc6b2804421f36a474094a">getField</a> (const char *fieldname, int32_t &amp;value) const  =0</td></tr>
<tr class="memdesc:ae2fc562045bc6b2804421f36a474094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int32_t type out param.  <a href="#ae2fc562045bc6b2804421f36a474094a">More...</a><br /></td></tr>
<tr class="separator:ae2fc562045bc6b2804421f36a474094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8076271f37067b5a612134dfa27e6322"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a8076271f37067b5a612134dfa27e6322">getField</a> (const char *fieldname, int64_t &amp;value) const  =0</td></tr>
<tr class="memdesc:a8076271f37067b5a612134dfa27e6322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int64_t type out param.  <a href="#a8076271f37067b5a612134dfa27e6322">More...</a><br /></td></tr>
<tr class="separator:a8076271f37067b5a612134dfa27e6322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff171b88c97241b734c8f5cf383edcb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#abff171b88c97241b734c8f5cf383edcb">getField</a> (const char *fieldname, float &amp;value) const  =0</td></tr>
<tr class="memdesc:abff171b88c97241b734c8f5cf383edcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in float type out param.  <a href="#abff171b88c97241b734c8f5cf383edcb">More...</a><br /></td></tr>
<tr class="separator:abff171b88c97241b734c8f5cf383edcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3418fd06180b5eaa2416044b568e38fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a3418fd06180b5eaa2416044b568e38fa">getField</a> (const char *fieldname, double &amp;value) const  =0</td></tr>
<tr class="memdesc:a3418fd06180b5eaa2416044b568e38fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in double type out param.  <a href="#a3418fd06180b5eaa2416044b568e38fa">More...</a><br /></td></tr>
<tr class="separator:a3418fd06180b5eaa2416044b568e38fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be81481bf44c6c7d285491e6458db70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a8be81481bf44c6c7d285491e6458db70">getField</a> (const char *fieldName, wchar_t &amp;value) const  =0</td></tr>
<tr class="memdesc:a8be81481bf44c6c7d285491e6458db70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in wchar_t type out param.  <a href="#a8be81481bf44c6c7d285491e6458db70">More...</a><br /></td></tr>
<tr class="separator:a8be81481bf44c6c7d285491e6458db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1250ae509abfa7e3949ea200afedda04"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a1250ae509abfa7e3949ea200afedda04">getField</a> (const char *fieldName, char &amp;value) const  =0</td></tr>
<tr class="memdesc:a1250ae509abfa7e3949ea200afedda04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in char type out param.  <a href="#a1250ae509abfa7e3949ea200afedda04">More...</a><br /></td></tr>
<tr class="separator:a1250ae509abfa7e3949ea200afedda04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e53b1c20b09aa03ebbb061d4ff86ba9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a8e53b1c20b09aa03ebbb061d4ff86ba9">getField</a> (const char *fieldname, bool **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:a8e53b1c20b09aa03ebbb061d4ff86ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in bool array type out param.  <a href="#a8e53b1c20b09aa03ebbb061d4ff86ba9">More...</a><br /></td></tr>
<tr class="separator:a8e53b1c20b09aa03ebbb061d4ff86ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109d78cad3d322f3250bb6972a4f56f2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a109d78cad3d322f3250bb6972a4f56f2">getField</a> (const char *fieldname, signed char **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:a109d78cad3d322f3250bb6972a4f56f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in signed char array type out param.  <a href="#a109d78cad3d322f3250bb6972a4f56f2">More...</a><br /></td></tr>
<tr class="separator:a109d78cad3d322f3250bb6972a4f56f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24889ecc8aab2437619a68a80516249"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aa24889ecc8aab2437619a68a80516249">getField</a> (const char *fieldname, unsigned char **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:aa24889ecc8aab2437619a68a80516249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in unsigned char array type out param.  <a href="#aa24889ecc8aab2437619a68a80516249">More...</a><br /></td></tr>
<tr class="separator:aa24889ecc8aab2437619a68a80516249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b6fa63c3523bd4c9a2e0dfa84ed86a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aa8b6fa63c3523bd4c9a2e0dfa84ed86a">getField</a> (const char *fieldname, int16_t **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:aa8b6fa63c3523bd4c9a2e0dfa84ed86a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int16_t array type out param.  <a href="#aa8b6fa63c3523bd4c9a2e0dfa84ed86a">More...</a><br /></td></tr>
<tr class="separator:aa8b6fa63c3523bd4c9a2e0dfa84ed86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739044c4a4c5d9d7b73a42727a4eceac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a739044c4a4c5d9d7b73a42727a4eceac">getField</a> (const char *fieldname, int32_t **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:a739044c4a4c5d9d7b73a42727a4eceac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int32_t array type out param.  <a href="#a739044c4a4c5d9d7b73a42727a4eceac">More...</a><br /></td></tr>
<tr class="separator:a739044c4a4c5d9d7b73a42727a4eceac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b54fd5f50c7a3b8ac2684d33c59ee9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a71b54fd5f50c7a3b8ac2684d33c59ee9">getField</a> (const char *fieldname, int64_t **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:a71b54fd5f50c7a3b8ac2684d33c59ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in int64_t array type out param.  <a href="#a71b54fd5f50c7a3b8ac2684d33c59ee9">More...</a><br /></td></tr>
<tr class="separator:a71b54fd5f50c7a3b8ac2684d33c59ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d9f8e4f355c153cc3e0a21fef425f7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a22d9f8e4f355c153cc3e0a21fef425f7">getField</a> (const char *fieldname, float **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:a22d9f8e4f355c153cc3e0a21fef425f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in float array type out param.  <a href="#a22d9f8e4f355c153cc3e0a21fef425f7">More...</a><br /></td></tr>
<tr class="separator:a22d9f8e4f355c153cc3e0a21fef425f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca55617bf1c2b846fb2387dfa11e5518"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aca55617bf1c2b846fb2387dfa11e5518">getField</a> (const char *fieldname, double **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:aca55617bf1c2b846fb2387dfa11e5518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in double array type out param.  <a href="#aca55617bf1c2b846fb2387dfa11e5518">More...</a><br /></td></tr>
<tr class="separator:aca55617bf1c2b846fb2387dfa11e5518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816e29cd4e34ca8dcd2f6a1aef03c603"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a816e29cd4e34ca8dcd2f6a1aef03c603">getField</a> (const char *fieldName, wchar_t **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:a816e29cd4e34ca8dcd2f6a1aef03c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in wchar_t array type out param.  <a href="#a816e29cd4e34ca8dcd2f6a1aef03c603">More...</a><br /></td></tr>
<tr class="separator:a816e29cd4e34ca8dcd2f6a1aef03c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d0a4df7c38f4e36af703f8d9426a72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ab8d0a4df7c38f4e36af703f8d9426a72">getField</a> (const char *fieldName, char **value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:ab8d0a4df7c38f4e36af703f8d9426a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in char array type out param.  <a href="#ab8d0a4df7c38f4e36af703f8d9426a72">More...</a><br /></td></tr>
<tr class="separator:ab8d0a4df7c38f4e36af703f8d9426a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9d1066b774bd2c85aeb8a237b5bca7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#afb9d1066b774bd2c85aeb8a237b5bca7">getField</a> (const char *fieldname, wchar_t **value) const  =0</td></tr>
<tr class="memdesc:afb9d1066b774bd2c85aeb8a237b5bca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in wchar_t* type out param.  <a href="#afb9d1066b774bd2c85aeb8a237b5bca7">More...</a><br /></td></tr>
<tr class="separator:afb9d1066b774bd2c85aeb8a237b5bca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24795df583d6cb7351e88693b9b2289"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#af24795df583d6cb7351e88693b9b2289">getField</a> (const char *fieldname, char **value) const  =0</td></tr>
<tr class="memdesc:af24795df583d6cb7351e88693b9b2289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in char* type out param.  <a href="#af24795df583d6cb7351e88693b9b2289">More...</a><br /></td></tr>
<tr class="separator:af24795df583d6cb7351e88693b9b2289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb88d45b3e198431600edfc373c11309"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#afb88d45b3e198431600edfc373c11309">getField</a> (const char *fieldname, wchar_t ***value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:afb88d45b3e198431600edfc373c11309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in wchar_t* array type out param.  <a href="#afb88d45b3e198431600edfc373c11309">More...</a><br /></td></tr>
<tr class="separator:afb88d45b3e198431600edfc373c11309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e09c3427a14427d1a84ea1bcdc7496"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ac9e09c3427a14427d1a84ea1bcdc7496">getField</a> (const char *fieldname, char ***value, int32_t &amp;length) const  =0</td></tr>
<tr class="memdesc:ac9e09c3427a14427d1a84ea1bcdc7496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in char* array type out param.  <a href="#ac9e09c3427a14427d1a84ea1bcdc7496">More...</a><br /></td></tr>
<tr class="separator:ac9e09c3427a14427d1a84ea1bcdc7496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631da316ef7f89d9d27e769452cbd9e0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a631da316ef7f89d9d27e769452cbd9e0">getField</a> (const char *fieldname, <a class="el" href="a00114.html">CacheableDatePtr</a> &amp;value) const  =0</td></tr>
<tr class="memdesc:a631da316ef7f89d9d27e769452cbd9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in CacheableDatePtr type out param.  <a href="#a631da316ef7f89d9d27e769452cbd9e0">More...</a><br /></td></tr>
<tr class="separator:a631da316ef7f89d9d27e769452cbd9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaa3bd68203de70e2e6aafbeb5fa22b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a0aaa3bd68203de70e2e6aafbeb5fa22b">getField</a> (const char *fieldName, int8_t ***value, int32_t &amp;arrayLength, int32_t *&amp;elementLength) const  =0</td></tr>
<tr class="memdesc:a0aaa3bd68203de70e2e6aafbeb5fa22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in array of byte arrays type out param.  <a href="#a0aaa3bd68203de70e2e6aafbeb5fa22b">More...</a><br /></td></tr>
<tr class="separator:a0aaa3bd68203de70e2e6aafbeb5fa22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2e677a70770b6afc5c02244b2c1803"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#abb2e677a70770b6afc5c02244b2c1803">getField</a> (const char *fieldname, <a class="el" href="a00114.html">CacheableObjectArrayPtr</a> &amp;value) const  =0</td></tr>
<tr class="memdesc:abb2e677a70770b6afc5c02244b2c1803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the named field and set its value in CacheableObjectArrayPtr type out param.  <a href="#abb2e677a70770b6afc5c02244b2c1803">More...</a><br /></td></tr>
<tr class="separator:abb2e677a70770b6afc5c02244b2c1803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced2fc58b340641d3537b0fc7d315963"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00112.html">CacheableStringArrayPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aced2fc58b340641d3537b0fc7d315963">getFieldNames</a> ()=0</td></tr>
<tr class="memdesc:aced2fc58b340641d3537b0fc7d315963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unmodifiable list of the field names on this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>.  <a href="#aced2fc58b340641d3537b0fc7d315963">More...</a><br /></td></tr>
<tr class="separator:aced2fc58b340641d3537b0fc7d315963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2c9416cdd13f048a2a49cd062c55d2"><td class="memItemLeft" align="right" valign="top">virtual PdxFieldTypes::PdxFieldType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#afd2c9416cdd13f048a2a49cd062c55d2">getFieldType</a> (const char *fieldname) const  =0</td></tr>
<tr class="memdesc:afd2c9416cdd13f048a2a49cd062c55d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type.  <a href="#afd2c9416cdd13f048a2a49cd062c55d2">More...</a><br /></td></tr>
<tr class="separator:afd2c9416cdd13f048a2a49cd062c55d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36882f1150ca0c2c9c3d4a780a7378"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00114.html">PdxSerializablePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#aea36882f1150ca0c2c9c3d4a780a7378">getObject</a> ()=0</td></tr>
<tr class="memdesc:aea36882f1150ca0c2c9c3d4a780a7378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserializes and returns the domain object that this instance represents.  <a href="#aea36882f1150ca0c2c9c3d4a780a7378">More...</a><br /></td></tr>
<tr class="separator:aea36882f1150ca0c2c9c3d4a780a7378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b8aa59dea8c3f8f7c25c3ea292e821"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821">hasField</a> (const char *fieldname)=0</td></tr>
<tr class="memdesc:ae3b8aa59dea8c3f8f7c25c3ea292e821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field exists and returns the result.  <a href="#ae3b8aa59dea8c3f8f7c25c3ea292e821">More...</a><br /></td></tr>
<tr class="separator:ae3b8aa59dea8c3f8f7c25c3ea292e821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2017581f2fdca0ab7d671a033dc6f1cf"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a2017581f2fdca0ab7d671a033dc6f1cf">hashcode</a> () const  =0</td></tr>
<tr class="memdesc:a2017581f2fdca0ab7d671a033dc6f1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hashcode based on the identity fields of this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>.  <a href="#a2017581f2fdca0ab7d671a033dc6f1cf">More...</a><br /></td></tr>
<tr class="separator:a2017581f2fdca0ab7d671a033dc6f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1597548fb252ccd47db9759848a2ec0e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a1597548fb252ccd47db9759848a2ec0e">isIdentityField</a> (const char *fieldname)=0</td></tr>
<tr class="memdesc:a1597548fb252ccd47db9759848a2ec0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the named field was <a class="el" href="a00094.html#a8a2d20dbc2801fc9805f28d5575576a3">PdxWriter#markIdentityField</a>marked as an identity field.  <a href="#a1597548fb252ccd47db9759848a2ec0e">More...</a><br /></td></tr>
<tr class="separator:a1597548fb252ccd47db9759848a2ec0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25df89b18c45389de711c46937bc8ab"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00031.html#ad25df89b18c45389de711c46937bc8ab">logString</a> (char *buffer, int32_t maxLength) const </td></tr>
<tr class="memdesc:ad25df89b18c45389de711c46937bc8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the string form of a key into a char* buffer for logging purposes.  <a href="#ad25df89b18c45389de711c46937bc8ab">More...</a><br /></td></tr>
<tr class="separator:ad25df89b18c45389de711c46937bc8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e04deac055c2311be1b863b8f86d25"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ae1e04deac055c2311be1b863b8f86d25">objectSize</a> () const  =0</td></tr>
<tr class="separator:ae1e04deac055c2311be1b863b8f86d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1dbdabfbee853ace2612e319b41300"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a8c1dbdabfbee853ace2612e319b41300">operator==</a> (const <a class="el" href="a00031.html">CacheableKey</a> &amp;other) const  =0</td></tr>
<tr class="memdesc:a8c1dbdabfbee853ace2612e319b41300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="a00031.html" title="Represents a cacheable key. ">CacheableKey</a> derived object is equals to this instance.  <a href="#a8c1dbdabfbee853ace2612e319b41300">More...</a><br /></td></tr>
<tr class="separator:a8c1dbdabfbee853ace2612e319b41300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af249217cc7b6a6cacadbf8cc4d50f405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html#af249217cc7b6a6cacadbf8cc4d50f405">preserveSB</a> () const </td></tr>
<tr class="memdesc:af249217cc7b6a6cacadbf8cc4d50f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment reference count.  <a href="#af249217cc7b6a6cacadbf8cc4d50f405">More...</a><br /></td></tr>
<tr class="separator:af249217cc7b6a6cacadbf8cc4d50f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d4f6e99f11b6df13f46383aedd2fd8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html#af0d4f6e99f11b6df13f46383aedd2fd8">refCount</a> ()</td></tr>
<tr class="separator:af0d4f6e99f11b6df13f46383aedd2fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4542c508cd9b6e87e231a8d8342860"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00113.html#a2f4542c508cd9b6e87e231a8d8342860">releaseSB</a> () const </td></tr>
<tr class="memdesc:a2f4542c508cd9b6e87e231a8d8342860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically decrement reference count, the <a class="el" href="a00113.html" title="This abstract base class is the base class of all user objects that have the shared capability of ref...">SharedBase</a> object is automatically deleted when its reference count goes to zero.  <a href="#a2f4542c508cd9b6e87e231a8d8342860">More...</a><br /></td></tr>
<tr class="separator:a2f4542c508cd9b6e87e231a8d8342860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7d2ea972f236160d22bf28da1c33c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a5f7d2ea972f236160d22bf28da1c33c2">setField</a> (const char *fieldName, <a class="el" href="a00114.html">CacheablePtr</a> value)=0</td></tr>
<tr class="memdesc:a5f7d2ea972f236160d22bf28da1c33c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a5f7d2ea972f236160d22bf28da1c33c2">More...</a><br /></td></tr>
<tr class="separator:a5f7d2ea972f236160d22bf28da1c33c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a8b81c3c177b8aef37b968be33502f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a35a8b81c3c177b8aef37b968be33502f">setField</a> (const char *fieldName, bool value)=0</td></tr>
<tr class="memdesc:a35a8b81c3c177b8aef37b968be33502f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a35a8b81c3c177b8aef37b968be33502f">More...</a><br /></td></tr>
<tr class="separator:a35a8b81c3c177b8aef37b968be33502f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ecd0233fdcf2bf8a812194a8ea9623"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ae9ecd0233fdcf2bf8a812194a8ea9623">setField</a> (const char *fieldName, signed char value)=0</td></tr>
<tr class="memdesc:ae9ecd0233fdcf2bf8a812194a8ea9623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ae9ecd0233fdcf2bf8a812194a8ea9623">More...</a><br /></td></tr>
<tr class="separator:ae9ecd0233fdcf2bf8a812194a8ea9623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c88ffc6bfdd547b5d5600288eb27b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ab9c88ffc6bfdd547b5d5600288eb27b2">setField</a> (const char *fieldName, unsigned char value)=0</td></tr>
<tr class="memdesc:ab9c88ffc6bfdd547b5d5600288eb27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ab9c88ffc6bfdd547b5d5600288eb27b2">More...</a><br /></td></tr>
<tr class="separator:ab9c88ffc6bfdd547b5d5600288eb27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5622bac5ccdd8638ae18a101d7d339de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a5622bac5ccdd8638ae18a101d7d339de">setField</a> (const char *fieldName, int16_t value)=0</td></tr>
<tr class="memdesc:a5622bac5ccdd8638ae18a101d7d339de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a5622bac5ccdd8638ae18a101d7d339de">More...</a><br /></td></tr>
<tr class="separator:a5622bac5ccdd8638ae18a101d7d339de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3693a832873f5aa82f87407eb47183"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#aec3693a832873f5aa82f87407eb47183">setField</a> (const char *fieldName, int32_t value)=0</td></tr>
<tr class="memdesc:aec3693a832873f5aa82f87407eb47183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#aec3693a832873f5aa82f87407eb47183">More...</a><br /></td></tr>
<tr class="separator:aec3693a832873f5aa82f87407eb47183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377ee542e2bc7b1c0cd3dbbac0bbf580"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a377ee542e2bc7b1c0cd3dbbac0bbf580">setField</a> (const char *fieldName, int64_t value)=0</td></tr>
<tr class="memdesc:a377ee542e2bc7b1c0cd3dbbac0bbf580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a377ee542e2bc7b1c0cd3dbbac0bbf580">More...</a><br /></td></tr>
<tr class="separator:a377ee542e2bc7b1c0cd3dbbac0bbf580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a6c02dd6acb1eaca23610fb28fcb83"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#af5a6c02dd6acb1eaca23610fb28fcb83">setField</a> (const char *fieldName, float value)=0</td></tr>
<tr class="memdesc:af5a6c02dd6acb1eaca23610fb28fcb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#af5a6c02dd6acb1eaca23610fb28fcb83">More...</a><br /></td></tr>
<tr class="separator:af5a6c02dd6acb1eaca23610fb28fcb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09c1586e0da16958cea74c3ffd8cd35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#af09c1586e0da16958cea74c3ffd8cd35">setField</a> (const char *fieldName, double value)=0</td></tr>
<tr class="memdesc:af09c1586e0da16958cea74c3ffd8cd35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#af09c1586e0da16958cea74c3ffd8cd35">More...</a><br /></td></tr>
<tr class="separator:af09c1586e0da16958cea74c3ffd8cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b332d8fcabc3c06f23ff138d5726c5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a65b332d8fcabc3c06f23ff138d5726c5">setField</a> (const char *fieldName, wchar_t value)=0</td></tr>
<tr class="memdesc:a65b332d8fcabc3c06f23ff138d5726c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a65b332d8fcabc3c06f23ff138d5726c5">More...</a><br /></td></tr>
<tr class="separator:a65b332d8fcabc3c06f23ff138d5726c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950bf91fd65a17624f7d272d226d47d2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a950bf91fd65a17624f7d272d226d47d2">setField</a> (const char *fieldName, char value)=0</td></tr>
<tr class="memdesc:a950bf91fd65a17624f7d272d226d47d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a950bf91fd65a17624f7d272d226d47d2">More...</a><br /></td></tr>
<tr class="separator:a950bf91fd65a17624f7d272d226d47d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea54dedc06347238def756eb2ccb4692"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#aea54dedc06347238def756eb2ccb4692">setField</a> (const char *fieldName, <a class="el" href="a00114.html">CacheableDatePtr</a> value)=0</td></tr>
<tr class="memdesc:aea54dedc06347238def756eb2ccb4692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#aea54dedc06347238def756eb2ccb4692">More...</a><br /></td></tr>
<tr class="separator:aea54dedc06347238def756eb2ccb4692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71f620084b058a51947a21c306d8571"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ae71f620084b058a51947a21c306d8571">setField</a> (const char *fieldName, bool *value, int32_t length)=0</td></tr>
<tr class="memdesc:ae71f620084b058a51947a21c306d8571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ae71f620084b058a51947a21c306d8571">More...</a><br /></td></tr>
<tr class="separator:ae71f620084b058a51947a21c306d8571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3d17e6126073e590939faaa18dba8e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a4d3d17e6126073e590939faaa18dba8e">setField</a> (const char *fieldName, signed char *value, int32_t length)=0</td></tr>
<tr class="memdesc:a4d3d17e6126073e590939faaa18dba8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a4d3d17e6126073e590939faaa18dba8e">More...</a><br /></td></tr>
<tr class="separator:a4d3d17e6126073e590939faaa18dba8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d1c22fcb2079592f00b890ae676f70"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a88d1c22fcb2079592f00b890ae676f70">setField</a> (const char *fieldName, unsigned char *value, int32_t length)=0</td></tr>
<tr class="memdesc:a88d1c22fcb2079592f00b890ae676f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a88d1c22fcb2079592f00b890ae676f70">More...</a><br /></td></tr>
<tr class="separator:a88d1c22fcb2079592f00b890ae676f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d4eb191d8ab210d323d9eb468a076"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ad14d4eb191d8ab210d323d9eb468a076">setField</a> (const char *fieldName, int16_t *value, int32_t length)=0</td></tr>
<tr class="memdesc:ad14d4eb191d8ab210d323d9eb468a076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ad14d4eb191d8ab210d323d9eb468a076">More...</a><br /></td></tr>
<tr class="separator:ad14d4eb191d8ab210d323d9eb468a076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dccbd6e9672f9682be08ea11f15eb37"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a6dccbd6e9672f9682be08ea11f15eb37">setField</a> (const char *fieldName, int32_t *value, int32_t length)=0</td></tr>
<tr class="memdesc:a6dccbd6e9672f9682be08ea11f15eb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a6dccbd6e9672f9682be08ea11f15eb37">More...</a><br /></td></tr>
<tr class="separator:a6dccbd6e9672f9682be08ea11f15eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b08419706622e856900e6d4c682576"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a10b08419706622e856900e6d4c682576">setField</a> (const char *fieldName, int64_t *value, int32_t length)=0</td></tr>
<tr class="memdesc:a10b08419706622e856900e6d4c682576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a10b08419706622e856900e6d4c682576">More...</a><br /></td></tr>
<tr class="separator:a10b08419706622e856900e6d4c682576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0797f8b81b3b329e0da340eb6c12ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ade0797f8b81b3b329e0da340eb6c12ac">setField</a> (const char *fieldName, float *value, int32_t length)=0</td></tr>
<tr class="memdesc:ade0797f8b81b3b329e0da340eb6c12ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ade0797f8b81b3b329e0da340eb6c12ac">More...</a><br /></td></tr>
<tr class="separator:ade0797f8b81b3b329e0da340eb6c12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ca9b4f6052152cdf23ccc7fb77e89e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a92ca9b4f6052152cdf23ccc7fb77e89e">setField</a> (const char *fieldName, double *value, int32_t length)=0</td></tr>
<tr class="memdesc:a92ca9b4f6052152cdf23ccc7fb77e89e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a92ca9b4f6052152cdf23ccc7fb77e89e">More...</a><br /></td></tr>
<tr class="separator:a92ca9b4f6052152cdf23ccc7fb77e89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb24600ed782a2247ba1a7e4c934dfb0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#acb24600ed782a2247ba1a7e4c934dfb0">setField</a> (const char *fieldName, const wchar_t *value)=0</td></tr>
<tr class="memdesc:acb24600ed782a2247ba1a7e4c934dfb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#acb24600ed782a2247ba1a7e4c934dfb0">More...</a><br /></td></tr>
<tr class="separator:acb24600ed782a2247ba1a7e4c934dfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a18c7ad24cc09514c3700dbc3adc98f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a4a18c7ad24cc09514c3700dbc3adc98f">setField</a> (const char *fieldName, const char *value)=0</td></tr>
<tr class="memdesc:a4a18c7ad24cc09514c3700dbc3adc98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a4a18c7ad24cc09514c3700dbc3adc98f">More...</a><br /></td></tr>
<tr class="separator:a4a18c7ad24cc09514c3700dbc3adc98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713c934136a40baea01a80d9e936a1dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a713c934136a40baea01a80d9e936a1dc">setField</a> (const char *fieldName, wchar_t *value, int32_t length)=0</td></tr>
<tr class="memdesc:a713c934136a40baea01a80d9e936a1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a713c934136a40baea01a80d9e936a1dc">More...</a><br /></td></tr>
<tr class="separator:a713c934136a40baea01a80d9e936a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7ed1500c8457a995a23db4f9a350a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a1d7ed1500c8457a995a23db4f9a350a1">setField</a> (const char *fieldName, char *value, int32_t length)=0</td></tr>
<tr class="memdesc:a1d7ed1500c8457a995a23db4f9a350a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a1d7ed1500c8457a995a23db4f9a350a1">More...</a><br /></td></tr>
<tr class="separator:a1d7ed1500c8457a995a23db4f9a350a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab765a1504fd3b1ab9693da5e05598e52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ab765a1504fd3b1ab9693da5e05598e52">setField</a> (const char *fieldName, wchar_t **value, int32_t length)=0</td></tr>
<tr class="memdesc:ab765a1504fd3b1ab9693da5e05598e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#ab765a1504fd3b1ab9693da5e05598e52">More...</a><br /></td></tr>
<tr class="separator:ab765a1504fd3b1ab9693da5e05598e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c1efa6bd9d005817395aeb1b9885dc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a77c1efa6bd9d005817395aeb1b9885dc">setField</a> (const char *fieldName, char **value, int32_t length)=0</td></tr>
<tr class="memdesc:a77c1efa6bd9d005817395aeb1b9885dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#a77c1efa6bd9d005817395aeb1b9885dc">More...</a><br /></td></tr>
<tr class="separator:a77c1efa6bd9d005817395aeb1b9885dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab3b16351b67af0c4a99de67e316fc1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#afab3b16351b67af0c4a99de67e316fc1">setField</a> (const char *fieldName, int8_t **value, int32_t arrayLength, int32_t *elementLength)=0</td></tr>
<tr class="memdesc:afab3b16351b67af0c4a99de67e316fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#afab3b16351b67af0c4a99de67e316fc1">More...</a><br /></td></tr>
<tr class="separator:afab3b16351b67af0c4a99de67e316fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec4f97f9141444fa0846a7f76a99653"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#aeec4f97f9141444fa0846a7f76a99653">setField</a> (const char *fieldName, <a class="el" href="a00114.html">CacheableObjectArrayPtr</a> value)=0</td></tr>
<tr class="memdesc:aeec4f97f9141444fa0846a7f76a99653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the existing named field to the given value.  <a href="#aeec4f97f9141444fa0846a7f76a99653">More...</a><br /></td></tr>
<tr class="separator:aeec4f97f9141444fa0846a7f76a99653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5004bd4ae57c505902cbd70c71740170"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a5004bd4ae57c505902cbd70c71740170">toData</a> (<a class="el" href="a00061.html">DataOutput</a> &amp;output) const </td></tr>
<tr class="memdesc:a5004bd4ae57c505902cbd70c71740170"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize this object.  <a href="#a5004bd4ae57c505902cbd70c71740170">More...</a><br /></td></tr>
<tr class="separator:a5004bd4ae57c505902cbd70c71740170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad911daa4b9508963837f6d6245bd4977"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#ad911daa4b9508963837f6d6245bd4977">toData</a> (<a class="el" href="a00114.html">PdxWriterPtr</a> output)=0</td></tr>
<tr class="memdesc:ad911daa4b9508963837f6d6245bd4977"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialize this object in geode PDX format.  <a href="#ad911daa4b9508963837f6d6245bd4977">More...</a><br /></td></tr>
<tr class="separator:ad911daa4b9508963837f6d6245bd4977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151c258b90f46971a28a8501ce6a688f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="a00114.html">CacheableStringPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00090.html#a151c258b90f46971a28a8501ce6a688f">toString</a> () const  =0</td></tr>
<tr class="memdesc:a151c258b90f46971a28a8501ce6a688f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints out all of the identity fields of this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>.  <a href="#a151c258b90f46971a28a8501ce6a688f">More...</a><br /></td></tr>
<tr class="separator:a151c258b90f46971a28a8501ce6a688f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013a46225edbc14966978c8092b1051b"><td class="memItemLeft" align="right" valign="top">virtual int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>typeId</b> () const </td></tr>
<tr class="memdesc:a013a46225edbc14966978c8092b1051b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the typeId byte of the instance being serialized.  <a href="#a013a46225edbc14966978c8092b1051b">More...</a><br /></td></tr>
<tr class="separator:a013a46225edbc14966978c8092b1051b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a0bc3e242f37ff742c3c2398a590ea"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#ad4a0bc3e242f37ff742c3c2398a590ea">~WritablePdxInstance</a> ()</td></tr>
<tr class="memdesc:ad4a0bc3e242f37ff742c3c2398a590ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">public methods  <a href="#ad4a0bc3e242f37ff742c3c2398a590ea">More...</a><br /></td></tr>
<tr class="separator:ad4a0bc3e242f37ff742c3c2398a590ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc694eaacffceec938397cc14d68533c"><td class="memTemplParams" colspan="2">template&lt;class PRIM &gt; </td></tr>
<tr class="memitem:afc694eaacffceec938397cc14d68533c"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="a00114.html">CacheableKeyPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00031.html#afc694eaacffceec938397cc14d68533c">create</a> (const PRIM value)</td></tr>
<tr class="memdesc:afc694eaacffceec938397cc14d68533c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory method that creates the key type that matches the type of value.  <a href="#afc694eaacffceec938397cc14d68533c">More...</a><br /></td></tr>
<tr class="separator:afc694eaacffceec938397cc14d68533c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7b889ccc949431792ebdc80c95091e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html#a8c7b889ccc949431792ebdc80c95091e">registerPdxSerializer</a> (<a class="el" href="a00114.html">PdxSerializerPtr</a> pdxSerializer)</td></tr>
<tr class="memdesc:a8c7b889ccc949431792ebdc80c95091e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the PDX serializer which can handle serialization for instances of user domain classes.  <a href="#a8c7b889ccc949431792ebdc80c95091e">More...</a><br /></td></tr>
<tr class="separator:a8c7b889ccc949431792ebdc80c95091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158b4afd81d58c8bea1e69a907a1d335"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335">registerPdxType</a> (TypeFactoryMethodPdx creationFunction)</td></tr>
<tr class="memdesc:a158b4afd81d58c8bea1e69a907a1d335"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an Pdx instance factory method for a given type.  <a href="#a158b4afd81d58c8bea1e69a907a1d335">More...</a><br /></td></tr>
<tr class="separator:a158b4afd81d58c8bea1e69a907a1d335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ec56c4c0fabc2be29089313a82693e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00111.html#ae9ec56c4c0fabc2be29089313a82693e">registerType</a> (TypeFactoryMethod creationFunction)</td></tr>
<tr class="memdesc:ae9ec56c4c0fabc2be29089313a82693e"><td class="mdescLeft">&#160;</td><td class="mdescRight">register an instance factory method for a given type.  <a href="#ae9ec56c4c0fabc2be29089313a82693e">More...</a><br /></td></tr>
<tr class="separator:ae9ec56c4c0fabc2be29089313a82693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8bdf1afb581d911236ff1a59a5bf349e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00134.html#a8bdf1afb581d911236ff1a59a5bf349e">WritablePdxInstance</a> ()</td></tr>
<tr class="memdesc:a8bdf1afb581d911236ff1a59a5bf349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructors  <a href="#a8bdf1afb581d911236ff1a59a5bf349e">More...</a><br /></td></tr>
<tr class="separator:a8bdf1afb581d911236ff1a59a5bf349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> is a <a class="el" href="a00090.html">PdxInstance</a> that also supports field modification using the <a class="el" href="a00134.html#a5f7d2ea972f236160d22bf28da1c33c2">setField</a> method. </p>
<p>To get a <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> call <a class="el" href="a00090.html#adf1d2ba7860c5dc723e54b5f89403822">PdxInstance#createWriter</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad4a0bc3e242f37ff742c3c2398a590ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual apache::geode::client::WritablePdxInstance::~WritablePdxInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>public methods </p>
<p>destructor </p>

</div>
</div>
<a class="anchor" id="a8bdf1afb581d911236ff1a59a5bf349e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">apache::geode::client::WritablePdxInstance::WritablePdxInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructors </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a748e22c93c5191d62b4109b3a4a2ea22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxSerializable::classId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the classId of the instance being serialized. </p>
<p>This is used by deserialization to determine what instance type to create and derserialize into. </p>

</div>
</div>
<a class="anchor" id="afc694eaacffceec938397cc14d68533c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PRIM &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="a00114.html">CacheableKeyPtr</a> apache::geode::client::CacheableKey::create </td>
          <td>(</td>
          <td class="paramtype">const PRIM&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Factory method that creates the key type that matches the type of value. </p>
<p>For customer defined derivations of <a class="el" href="a00031.html" title="Represents a cacheable key. ">CacheableKey</a>, the method apache::geode::client::createKey may be overloaded. For pointer types (e.g. char*) the method apache::geode::client::createKeyArr may be overloaded. </p>

</div>
</div>
<a class="anchor" id="adf1d2ba7860c5dc723e54b5f89403822"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00114.html">WritablePdxInstancePtr</a> apache::geode::client::PdxInstance::createWriter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates and returns a <a class="el" href="a00134.html">WritablePdxInstance</a> whose initial values are those of this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </p>
<p>This call returns a copy of the current field values so modifications made to the returned value will not modify this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="a00134.html">WritablePdxInstance</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad1182350fed20df81b0cfe45a39ffbda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t apache::geode::client::Serializable::DSFID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the Data Serialization Fixed ID type. </p>
<p>This is used to determine what instance type to create and deserialize into.</p>
<p>Note that this should not be overridden by custom implementations and is reserved only for builtin types. </p>

<p>Reimplemented in <a class="el" href="a00120.html#a526f78d39a4785a7f48a2566f33184c9">apache::geode::client::Struct</a>, and <a class="el" href="a00039.html#a8842fee3a919551c9bdab8bd1f8686c5">apache::geode::client::CacheableUndefined</a>.</p>

</div>
</div>
<a class="anchor" id="ad68c6cbf19dec3ff13d557aa5dbf6fca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00111.html">Serializable</a>* apache::geode::client::PdxInstance::fromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00060.html">DataInput</a> &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deserialize this object, typical implementation should return the 'this' pointer. </p>
<p>This is an internal method. </p>

<p>Implements <a class="el" href="a00111.html#ad8055bb012be46a3dc547c9a335e4638">apache::geode::client::Serializable</a>.</p>

</div>
</div>
<a class="anchor" id="aa3ae5bd2177a88851489c3423cb28fc9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::fromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00114.html">PdxReaderPtr</a>&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserialize this object. </p>
<p>This is an internal method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a00092.html" title="A PdxReader will be passed to PdxSerializable.fromData or during deserialization of a PDX...">PdxReader</a></td><td>to Deserialize the PDX object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2bef4757b29a88942ecc027950c430d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* apache::geode::client::PdxInstance::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the full name of the class that this pdx instance represents. </p>
<dl class="section return"><dt>Returns</dt><dd>the name of the class that this pdx instance represents. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa107b69cf82dca9eca4ad034087c294a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in CacheablePtr type out param. </p>
<p>CacheablePtr type is corresponding to java object type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with CacheablePtr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field. For deserialization C++ Native Client requires the domain class to be registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335" title="register an Pdx instance factory method for a given type. ">Serializable::registerPdxType</a> </dd>
<dd>
<a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7efee322a3a99ea3407d82f952fd30e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in bool type out param. </p>
<p>bool type is corresponding to java boolean type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with bool type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8bd369059273e0bee6275a5f8252e019"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in signed char type out param. </p>
<p>signed char type is corresponding to java byte type. For C++ on Windows and Linux, signed char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to signed char. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with signed char type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaf91989aeda1b4bac7da736668c1a484"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in unsigned char type out param. </p>
<p>unsigned char type is corresponding to java byte type. For C++ on Windows and Linux, unsigned char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to unsigned char. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with unsigned char type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae00f6bf6d71914ac0fc5dcf8c88419b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int16_t type out param. </p>
<p>int16_t type is corresponding to java short type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int16_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2fc562045bc6b2804421f36a474094a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int32_t type out param. </p>
<p>int32_t type is corresponding to java int type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int32_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8076271f37067b5a612134dfa27e6322"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int64_t type out param. </p>
<p>int64_t type is corresponding to java long type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int64_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abff171b88c97241b734c8f5cf383edcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in float type out param. </p>
<p>float type is corresponding to java float type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with float type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3418fd06180b5eaa2416044b568e38fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in double type out param. </p>
<p>double type is corresponding to java double type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with double type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8be81481bf44c6c7d285491e6458db70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in wchar_t type out param. </p>
<p>wchar_t type is corresponding to java char type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with wchar_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1250ae509abfa7e3949ea200afedda04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in char type out param. </p>
<p>char type is corresponding to java char type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with char type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8e53b1c20b09aa03ebbb061d4ff86ba9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in bool array type out param. </p>
<p>bool* type is corresponding to java boolean[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with bool array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of bool elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a109d78cad3d322f3250bb6972a4f56f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in signed char array type out param. </p>
<p>signed char* type is corresponding to java byte[] type. For C++ on Windows and Linux, signed char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to signed char*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with signed char array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of signed char elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa24889ecc8aab2437619a68a80516249"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in unsigned char array type out param. </p>
<p>unsigned char* type is corresponding to java byte[] type. For C++ on Windows and Linux, unsigned char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to unsigned char*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with unsigned char array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of unsigned char elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa8b6fa63c3523bd4c9a2e0dfa84ed86a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int16_t array type out param. </p>
<p>int16_t* type is corresponding to java short[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int16_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int16_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a739044c4a4c5d9d7b73a42727a4eceac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int32_t array type out param. </p>
<p>int32_t* type is corresponding to java int[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int32_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int32_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71b54fd5f50c7a3b8ac2684d33c59ee9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in int64_t array type out param. </p>
<p>int64_t* type is corresponding to java long[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with int64_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of int64_t elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22d9f8e4f355c153cc3e0a21fef425f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in float array type out param. </p>
<p>float* type is corresponding to java float[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with float array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of float elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca55617bf1c2b846fb2387dfa11e5518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in double array type out param. </p>
<p>double* type is corresponding to java double[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with double array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of double elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a816e29cd4e34ca8dcd2f6a1aef03c603"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in wchar_t array type out param. </p>
<p>wchar_t* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with wchar_t array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of wchar_t* elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d0a4df7c38f4e36af703f8d9426a72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in char array type out param. </p>
<p>char* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with char array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of char* elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb9d1066b774bd2c85aeb8a237b5bca7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in wchar_t* type out param. </p>
<p>wchar_t* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with wchar_t type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af24795df583d6cb7351e88693b9b2289"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in char* type out param. </p>
<p>char* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with char* type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb88d45b3e198431600edfc373c11309"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t ***&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in wchar_t* array type out param. </p>
<p>wchar_t** type is corresponding to java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with wchar_t* array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of wchar_t** elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac9e09c3427a14427d1a84ea1bcdc7496"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in char* array type out param. </p>
<p>char** type is corresponding to java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with char* array type. </td></tr>
    <tr><td class="paramname">length</td><td>length is set with number of char** elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a631da316ef7f89d9d27e769452cbd9e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">CacheableDatePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in CacheableDatePtr type out param. </p>
<p>CacheableDatePtr type is corresponding to java Java.util.date type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with CacheableDatePtr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0aaa3bd68203de70e2e6aafbeb5fa22b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t ***&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&amp;&#160;</td>
          <td class="paramname"><em>elementLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in array of byte arrays type out param. </p>
<p>int8_t** type is corresponding to java byte[][] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read. </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with array of byte arrays type. </td></tr>
    <tr><td class="paramname">arrayLength</td><td>arrayLength is set to the number of byte arrays. </td></tr>
    <tr><td class="paramname">elementLength</td><td>elementLength is set to individual byte array lengths. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abb2e677a70770b6afc5c02244b2c1803"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::getField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">CacheableObjectArrayPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the named field and set its value in CacheableObjectArrayPtr type out param. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. CacheableObjectArrayPtr type is corresponding to java Object[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>name of the field to read. </td></tr>
    <tr><td class="paramname">value</td><td>value of the field to be set with CacheableObjectArrayPtr type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> doesn't has the named field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335" title="register an Pdx instance factory method for a given type. ">Serializable::registerPdxType</a> </dd>
<dd>
<a class="el" href="a00090.html#ae3b8aa59dea8c3f8f7c25c3ea292e821" title="Checks if the named field exists and returns the result. ">PdxInstance::hasField</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aced2fc58b340641d3537b0fc7d315963"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00112.html">CacheableStringArrayPtr</a> apache::geode::client::PdxInstance::getFieldNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an unmodifiable list of the field names on this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>an unmodifiable list of the field names on this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afd2c9416cdd13f048a2a49cd062c55d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual PdxFieldTypes::PdxFieldType apache::geode::client::PdxInstance::getFieldType </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the type. </p>
<dl class="section see"><dt>See also</dt><dd>PdxInstance::PdxFieldTypes of the field in the pdx instance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the type </dd></dl>
<dl class="section see"><dt>See also</dt><dd>PdxInstance::PdxFieldTypes of the field in the pdx instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> typeid is not defined yet, to get classname or if PdxType is not defined for <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea36882f1150ca0c2c9c3d4a780a7378"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00114.html">PdxSerializablePtr</a> apache::geode::client::PdxInstance::getObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deserializes and returns the domain object that this instance represents. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. </p><dl class="section return"><dt>Returns</dt><dd>the deserialized domain object.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335" title="register an Pdx instance factory method for a given type. ">Serializable::registerPdxType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3b8aa59dea8c3f8f7c25c3ea292e821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::hasField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field exists and returns the result. </p>
<p>This can be useful when writing code that handles more than one version of a PDX class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="a2017581f2fdca0ab7d671a033dc6f1cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::PdxInstance::hashcode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a hashcode based on the identity fields of this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </p>
<p>If a <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> has marked identity fields using <a class="el" href="a00094.html#a8a2d20dbc2801fc9805f28d5575576a3">PdxWriter#markIdentityField</a> then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. </p>
<p>For deserialization C++ Native Client requires the domain class to be registered. If the field is an array then all array elements are used for hashcode computation. Otherwise the raw bytes of its value are used to compute the hash code. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the field contains an element that is not of <a class="el" href="a00031.html" title="Represents a cacheable key. ">CacheableKey</a> derived type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335" title="register an Pdx instance factory method for a given type. ">Serializable::registerPdxType</a> </dd></dl>

<p>Implements <a class="el" href="a00031.html#a8ab86de5d2e463503e256ef57b85dc69">apache::geode::client::CacheableKey</a>.</p>

</div>
</div>
<a class="anchor" id="a1597548fb252ccd47db9759848a2ec0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::isIdentityField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the named field was <a class="el" href="a00094.html#a8a2d20dbc2801fc9805f28d5575576a3">PdxWriter#markIdentityField</a>marked as an identity field. </p>
<p>Note that if no fields have been marked then all the fields are used as identity fields even though this method will return <code>false</code> since none of them have been <em>marked</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldname</td><td>the name of the field to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the named field exists and was marked as an identify field; otherwise <code>false</code> </dd></dl>

</div>
</div>
<a class="anchor" id="ad25df89b18c45389de711c46937bc8ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t apache::geode::client::CacheableKey::logString </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>maxLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the string form of a key into a char* buffer for logging purposes. </p>
<p>Implementations should only generate a string as long as maxLength chars, and return the number of chars written. buffer is expected to be large enough to hold at least maxLength chars.</p>
<p>The default implementation renders the classname and instance address. </p>

<p>Reimplemented in <a class="el" href="a00037.html#a11e4a981a01fce2dc5b97578fce41e2f">apache::geode::client::CacheableString</a>, <a class="el" href="a00014.html#a7a317daffc559700174d114f36e1d023">apache::geode::client::CacheableDate</a>, and <a class="el" href="a00032.html#afdcf3d72079c4d4d7017f266bebb6024">apache::geode::client::CacheableKeyType&lt; TObj, TYPEID, TYPENAME, SPRINTFSYM, STRSIZE &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ae1e04deac055c2311be1b863b8f86d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t apache::geode::client::PdxInstance::objectSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the size of the object in bytes This is an internal method. It is used in case of heap LRU property is set. </dd></dl>

<p>Reimplemented from <a class="el" href="a00111.html#ab3ba9bc770ce312bc6f94742bb995a04">apache::geode::client::Serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a8c1dbdabfbee853ace2612e319b41300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool apache::geode::client::PdxInstance::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00031.html">CacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="a00031.html" title="Represents a cacheable key. ">CacheableKey</a> derived object is equals to this instance. </p>
<p>If <code>other</code> is not a <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> then it is not equal to this instance. NOTE: Even if <code>other</code> is the result of calling <a class="el" href="a00090.html#aea36882f1150ca0c2c9c3d4a780a7378">getObject()</a> it will not be equal to this instance</p>
<p>. </p>
<p>Otherwise equality of two PdxInstances is determined as follows: </p><ol>
<li>
The domain class name must be equal for both PdxInstances </li>
<li>
Each identity field must be equal. </li>
</ol>
<p>If one of the instances does not have a field that the other one does then equals will assume it has the field with a default value. If a <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> has marked identity fields using <a class="el" href="a00094.html#a8a2d20dbc2801fc9805f28d5575576a3">markIdentityField</a> then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields. </p>
<p>An identity field is equal if all the following are true: </p><ol>
<li>
The field name is equal. </li>
<li>
The field type is equal. </li>
<li>
The field value is equal. </li>
</ol>
<p>If an identity field is of type derived from <code>Cacheable</code> then it is deserialized. For deserialization C++ Native Client requires the domain class to be registered. If the deserialized object is an array then all array elements are used to determine equality. If an identity field is of type <code><a class="el" href="a00035.html" title="Implement an immutable Vector of Cacheable objects that can serve as a distributable object for cachi...">CacheableObjectArray</a></code> then it is deserialized and all array elements are used to determine equality. For all other field types the value does not need to be deserialized. Instead the serialized raw bytes are compared and used to determine equality. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the other instance to compare to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if this instance is equal to <code>other</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the field contains an element that is not of <a class="el" href="a00031.html" title="Represents a cacheable key. ">CacheableKey</a> derived type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335" title="register an Pdx instance factory method for a given type. ">Serializable::registerPdxType</a> </dd></dl>

<p>Implements <a class="el" href="a00031.html#aee61a7a202af533def3ce9e19033de71">apache::geode::client::CacheableKey</a>.</p>

</div>
</div>
<a class="anchor" id="af249217cc7b6a6cacadbf8cc4d50f405"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::SharedBase::preserveSB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically increment reference count. </p>

</div>
</div>
<a class="anchor" id="af0d4f6e99f11b6df13f46383aedd2fd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t apache::geode::client::SharedBase::refCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the reference count </dd></dl>

</div>
</div>
<a class="anchor" id="a8c7b889ccc949431792ebdc80c95091e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void apache::geode::client::Serializable::registerPdxSerializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00114.html">PdxSerializerPtr</a>&#160;</td>
          <td class="paramname"><em>pdxSerializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the PDX serializer which can handle serialization for instances of user domain classes. </p>
<dl class="section see"><dt>See also</dt><dd>PdxSerializer </dd></dl>

</div>
</div>
<a class="anchor" id="a158b4afd81d58c8bea1e69a907a1d335"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void apache::geode::client::Serializable::registerPdxType </td>
          <td>(</td>
          <td class="paramtype">TypeFactoryMethodPdx&#160;</td>
          <td class="paramname"><em>creationFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register an Pdx instance factory method for a given type. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the typeName has already been registered, or there is an error in registering the type; check errno for more information in the latter case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9ec56c4c0fabc2be29089313a82693e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void apache::geode::client::Serializable::registerType </td>
          <td>(</td>
          <td class="paramtype">TypeFactoryMethod&#160;</td>
          <td class="paramname"><em>creationFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>register an instance factory method for a given type. </p>
<p>During registration the factory will be invoked to extract the typeId to associate with this function. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the typeId has already been registered, or there is an error in registering the type; check errno for more information in the latter case. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f4542c508cd9b6e87e231a8d8342860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void apache::geode::client::SharedBase::releaseSB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically decrement reference count, the <a class="el" href="a00113.html" title="This abstract base class is the base class of all user objects that have the shared capability of ref...">SharedBase</a> object is automatically deleted when its reference count goes to zero. </p>

</div>
</div>
<a class="anchor" id="a5f7d2ea972f236160d22bf28da1c33c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">CacheablePtr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. CacheablePtr type is corresponding to java object type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type CacheablePtr </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35a8b81c3c177b8aef37b968be33502f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. bool type is corresponding to java boolean type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9ecd0233fdcf2bf8a812194a8ea9623"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. signed char type is corresponding to java byte type. For C++ on Windows and Linux, signed char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to signed char. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type signed char </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9c88ffc6bfdd547b5d5600288eb27b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. unsigned char type is corresponding to java byte type. For C++ on Windows and Linux, unsigned char type is corresponding to int8_t type. However C++ users on Solaris should always use this api after casting int8_t to unsigned char. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type unsigned char </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5622bac5ccdd8638ae18a101d7d339de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int16_t type is corresponding to java short type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int16_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec3693a832873f5aa82f87407eb47183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int32_t type is corresponding to java int type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int32_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a377ee542e2bc7b1c0cd3dbbac0bbf580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int64_t type is corresponding to java long type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int64_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5a6c02dd6acb1eaca23610fb28fcb83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. float type is corresponding to java float type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type float </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af09c1586e0da16958cea74c3ffd8cd35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. double type is corresponding to java double type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type double </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65b332d8fcabc3c06f23ff138d5726c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t type is corresponding to java char type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type wchar_t </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a950bf91fd65a17624f7d272d226d47d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char type is corresponding to java char type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea54dedc06347238def756eb2ccb4692"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">CacheableDatePtr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. CacheableDatePtr type is corresponding to java Java.util.date type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type CacheableDatePtr </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae71f620084b058a51947a21c306d8571"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. bool* type is corresponding to java boolean[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type bool array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in bool array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d3d17e6126073e590939faaa18dba8e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. signed char* type is corresponding to java byte[] type. For C++ on Windows and Linux, signed char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to signed char*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type signed char array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in signed char array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88d1c22fcb2079592f00b890ae676f70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. unsigned char* type is corresponding to java byte[] type. For C++ on Windows and Linux, unsigned char* type is corresponding to int8_t* type. However C++ users on Solaris should always use this api after casting int8_t* to unsigned char*. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type unsigned char array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in unsigned char array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad14d4eb191d8ab210d323d9eb468a076"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int16_t* type is corresponding to java short[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int16_t array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in int16_t array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dccbd6e9672f9682be08ea11f15eb37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int32_t* type is corresponding to java int[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int32_t array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in int32_t array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10b08419706622e856900e6d4c682576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int64_t* type is corresponding to java long[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type int64_t array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in int64_t array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade0797f8b81b3b329e0da340eb6c12ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. float* type is corresponding to java float[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type float array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in float array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92ca9b4f6052152cdf23ccc7fb77e89e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. double* type is corresponding to java double[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type double array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in double array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb24600ed782a2247ba1a7e4c934dfb0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type wchar_t* </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a18c7ad24cc09514c3700dbc3adc98f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char* type is corresponding to java String type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char* </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a713c934136a40baea01a80d9e936a1dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t* type is corresponding to java char[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type wchar_t array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in wchar_t array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d7ed1500c8457a995a23db4f9a350a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char* type is corresponding to java char[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in char array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab765a1504fd3b1ab9693da5e05598e52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. wchar_t** type is corresponding to java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type wchar_t* array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in WCString array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77c1efa6bd9d005817395aeb1b9885dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. char** type is corresponding to java String[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type char* array </td></tr>
    <tr><td class="paramname">length</td><td>The number of elements in CString array type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afab3b16351b67af0c4a99de67e316fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t **&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>arrayLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>elementLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. int8_t** type is corresponding to java byte[][] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type array of byte arrays </td></tr>
    <tr><td class="paramname">arrayLength</td><td>The number of byte arrays. </td></tr>
    <tr><td class="paramname">elementLength</td><td>The lengths of individual byte arrays. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeec4f97f9141444fa0846a7f76a99653"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::WritablePdxInstance::setField </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fieldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00114.html">CacheableObjectArrayPtr</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the existing named field to the given value. </p>
<p>The setField method has copy-on-write semantics. So for the modifications to be stored in the cache the <a class="el" href="a00134.html" title="WritablePdxInstance is a PdxInstance that also supports field modification using the setField method...">WritablePdxInstance</a> must be put into a region after setField has been called one or more times. CacheableObjectArrayPtr type is corresponding to java Object[] type. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fieldName</td><td>name of the field whose value will be set </td></tr>
    <tr><td class="paramname">value</td><td>value that will be set to the field of type CacheableObjectArrayPtr </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>if the named field does not exist or if the type of the value is not compatible with the field. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5004bd4ae57c505902cbd70c71740170"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::toData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00061.html">DataOutput</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialize this object. </p>
<p>This is an internal method. </p>

<p>Implements <a class="el" href="a00111.html#aaa9491c6a853b0b969e1e51698628ae3">apache::geode::client::Serializable</a>.</p>

</div>
</div>
<a class="anchor" id="ad911daa4b9508963837f6d6245bd4977"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void apache::geode::client::PdxInstance::toData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00114.html">PdxWriterPtr</a>&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>serialize this object in geode PDX format. </p>
<p>This is an internal method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="a00094.html" title="A PdxWriter will be passed to PdxSerializable.toData when it is serializing the domain class...">PdxWriter</a></td><td>to serialize the PDX object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a151c258b90f46971a28a8501ce6a688f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="a00114.html">CacheableStringPtr</a> apache::geode::client::PdxInstance::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints out all of the identity fields of this <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a>. </p>
<p>If a <a class="el" href="a00090.html" title="PdxInstance provides run time access to the fields of a PDX without deserializing the PDX...">PdxInstance</a> has marked identity fields using <a class="el" href="a00094.html#a8a2d20dbc2801fc9805f28d5575576a3">PdxWriter#markIdentityField</a> then only the marked identity fields are its identity fields. Otherwise all its fields are identity fields</p>
<p>. For deserialization C++ Native Client requires the domain class to be registered.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="a00111.html#a158b4afd81d58c8bea1e69a907a1d335" title="register an Pdx instance factory method for a given type. ">Serializable::registerPdxType</a> </dd></dl>

<p>Reimplemented from <a class="el" href="a00111.html#a6b960d1989ac2c6cea1b41ff22669e2b">apache::geode::client::Serializable</a>.</p>

</div>
</div>
<a class="anchor" id="a013a46225edbc14966978c8092b1051b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int8_t apache::geode::client::PdxSerializable::typeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the typeId byte of the instance being serialized. </p>
<p>This is used by deserialization to determine what instance type to create and deserialize into.</p>
<p>Note that this should not be overridden by custom implementations and is reserved only for builtin types. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at
     http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<HR><address style="align: right;"><small>Pivotal GemFire C++ Cache API Documentation</small></address>
