<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Pivotal GemFire Native Client Cache Reference: gemfire::Region Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pivotal GemFire Native Client Cache Reference
   &#160;<span id="projectnumber">9.0.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classgemfire_1_1_region.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">gemfire::Region Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class manages subregions and cached data.  
 <a href="classgemfire_1_1_region.html#details">More...</a></p>

<p>Inherits <a class="el" href="classgemfire_1_1_shared_base.html">gemfire::SharedBase</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad84d7304ac66099bddfcb367e064ac61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ad84d7304ac66099bddfcb367e064ac61">clear</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:ad84d7304ac66099bddfcb367e064ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> invoked in the process.  <a href="#ad84d7304ac66099bddfcb367e064ac61">More...</a><br /></td></tr>
<tr class="separator:ad84d7304ac66099bddfcb367e064ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb7477fa661a96f1b6a6fd51f815825"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a5cb7477fa661a96f1b6a6fd51f815825">containsKey</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;keyPtr) const  =0</td></tr>
<tr class="memdesc:a5cb7477fa661a96f1b6a6fd51f815825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only the client's cache is searched for the key.  <a href="#a5cb7477fa661a96f1b6a6fd51f815825">More...</a><br /></td></tr>
<tr class="separator:a5cb7477fa661a96f1b6a6fd51f815825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a769fd54be4a0ee7a672a634cce347254"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a769fd54be4a0ee7a672a634cce347254"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a769fd54be4a0ee7a672a634cce347254">containsKey</a> (const KEYTYPE &amp;key) const </td></tr>
<tr class="memdesc:a769fd54be4a0ee7a672a634cce347254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char* This operations checks for the key in the local cache .  <a href="#a769fd54be4a0ee7a672a634cce347254">More...</a><br /></td></tr>
<tr class="separator:a769fd54be4a0ee7a672a634cce347254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cbd42ce77bb58c3d515de21ad6c1da7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a0cbd42ce77bb58c3d515de21ad6c1da7">containsKeyOnServer</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;keyPtr) const  =0</td></tr>
<tr class="memdesc:a0cbd42ce77bb58c3d515de21ad6c1da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cache of the server, to which it is connected with, is searched for the key to see if the key is present.  <a href="#a0cbd42ce77bb58c3d515de21ad6c1da7">More...</a><br /></td></tr>
<tr class="separator:a0cbd42ce77bb58c3d515de21ad6c1da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d2ce760fa976ae4ec7d7a5ac8fe91c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aa6d2ce760fa976ae4ec7d7a5ac8fe91c">containsValueForKey</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;keyPtr) const  =0</td></tr>
<tr class="memdesc:aa6d2ce760fa976ae4ec7d7a5ac8fe91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operations checks for the value in the local cache .  <a href="#aa6d2ce760fa976ae4ec7d7a5ac8fe91c">More...</a><br /></td></tr>
<tr class="separator:aa6d2ce760fa976ae4ec7d7a5ac8fe91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50011f336b4f2257fb66982c6e2b1b1"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ab50011f336b4f2257fb66982c6e2b1b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ab50011f336b4f2257fb66982c6e2b1b1">containsValueForKey</a> (const KEYTYPE &amp;key) const </td></tr>
<tr class="memdesc:ab50011f336b4f2257fb66982c6e2b1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char* This operations checks for the value in the local cache .  <a href="#ab50011f336b4f2257fb66982c6e2b1b1">More...</a><br /></td></tr>
<tr class="separator:ab50011f336b4f2257fb66982c6e2b1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb3c05a5fa94a1950a9fb2cb90ec5eb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aecb3c05a5fa94a1950a9fb2cb90ec5eb">create</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:aecb3c05a5fa94a1950a9fb2cb90ec5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new entry in this region with the specified key and value, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#aecb3c05a5fa94a1950a9fb2cb90ec5eb">More...</a><br /></td></tr>
<tr class="separator:aecb3c05a5fa94a1950a9fb2cb90ec5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054c1dbb45e8d3c824c8f38d2255e08e"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a054c1dbb45e8d3c824c8f38d2255e08e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a054c1dbb45e8d3c824c8f38d2255e08e">create</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a054c1dbb45e8d3c824c8f38d2255e08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a054c1dbb45e8d3c824c8f38d2255e08e">More...</a><br /></td></tr>
<tr class="separator:a054c1dbb45e8d3c824c8f38d2255e08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccfdcf0e0d35711f18e87401a48b326"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a4ccfdcf0e0d35711f18e87401a48b326"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a4ccfdcf0e0d35711f18e87401a48b326">create</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a4ccfdcf0e0d35711f18e87401a48b326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a4ccfdcf0e0d35711f18e87401a48b326">More...</a><br /></td></tr>
<tr class="separator:a4ccfdcf0e0d35711f18e87401a48b326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2324fe6f8effeabf001475d1469f9ffc"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a2324fe6f8effeabf001475d1469f9ffc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a2324fe6f8effeabf001475d1469f9ffc">create</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a2324fe6f8effeabf001475d1469f9ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a2324fe6f8effeabf001475d1469f9ffc">More...</a><br /></td></tr>
<tr class="separator:a2324fe6f8effeabf001475d1469f9ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b66d56b2d0074be11e82c877fbd2180"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a4b66d56b2d0074be11e82c877fbd2180">createSubregion</a> (const char *subregionName, const <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionAttributesPtr</a> &amp;aRegionAttributes)=0</td></tr>
<tr class="memdesc:a4b66d56b2d0074be11e82c877fbd2180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a subregion with the specified attributes.  <a href="#a4b66d56b2d0074be11e82c877fbd2180">More...</a><br /></td></tr>
<tr class="separator:a4b66d56b2d0074be11e82c877fbd2180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dd235083a3f598869ff5331a2b194e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e">destroy</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a41dd235083a3f598869ff5331a2b194e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the entry with the specified key, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a41dd235083a3f598869ff5331a2b194e">More...</a><br /></td></tr>
<tr class="separator:a41dd235083a3f598869ff5331a2b194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845f81574d338fd7d82331ed54ebb59b"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a845f81574d338fd7d82331ed54ebb59b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a845f81574d338fd7d82331ed54ebb59b">destroy</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a845f81574d338fd7d82331ed54ebb59b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a845f81574d338fd7d82331ed54ebb59b">More...</a><br /></td></tr>
<tr class="separator:a845f81574d338fd7d82331ed54ebb59b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b07a940ee17e375c45421e85b27a8ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a2b07a940ee17e375c45421e85b27a8ff">destroyRegion</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a2b07a940ee17e375c45421e85b27a8ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a2b07a940ee17e375c45421e85b27a8ff">More...</a><br /></td></tr>
<tr class="separator:a2b07a940ee17e375c45421e85b27a8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a6aca22412dc1e5ea1645866d4ed3d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a70a6aca22412dc1e5ea1645866d4ed3d">existsValue</a> (const char *predicate, uint32_t timeout=<a class="el" href="gf__base_8hpp.html#a3652aa8957738101aa9d01b236305604">DEFAULT_QUERY_RESPONSE_TIMEOUT</a>)=0</td></tr>
<tr class="memdesc:a70a6aca22412dc1e5ea1645866d4ed3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the query on the server based on the predicate and returns whether any result exists.  <a href="#a70a6aca22412dc1e5ea1645866d4ed3d">More...</a><br /></td></tr>
<tr class="separator:a70a6aca22412dc1e5ea1645866d4ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6417a042b32bba4bd39011dc5909f4c1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a6417a042b32bba4bd39011dc5909f4c1">get</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a6417a042b32bba4bd39011dc5909f4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value associated with the specified key, passing the callback argument to any cache loaders that are invoked in the operation.  <a href="#a6417a042b32bba4bd39011dc5909f4c1">More...</a><br /></td></tr>
<tr class="separator:a6417a042b32bba4bd39011dc5909f4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac63871ceb4380d41b5963afe3001c6"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a4ac63871ceb4380d41b5963afe3001c6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a4ac63871ceb4380d41b5963afe3001c6">get</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;callbackArg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a4ac63871ceb4380d41b5963afe3001c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a4ac63871ceb4380d41b5963afe3001c6">More...</a><br /></td></tr>
<tr class="separator:a4ac63871ceb4380d41b5963afe3001c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ecc65a069fa2418fe0c5de0e903541"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a14ecc65a069fa2418fe0c5de0e903541">getAll</a> (const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;<a class="el" href="classgemfire_1_1_region.html#ad49244bb426dd2d2aa7443e5fed8e229">keys</a>, <a class="el" href="classgemfire_1_1_shared_ptr.html">HashMapOfCacheablePtr</a> <a class="el" href="classgemfire_1_1_region.html#a7d25cce2f2fcff0ba37e3f8f43c345b1">values</a>, <a class="el" href="classgemfire_1_1_shared_ptr.html">HashMapOfExceptionPtr</a> exceptions, bool addToLocalCache=false, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a14ecc65a069fa2418fe0c5de0e903541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets values for an array of keys from the local cache or server.  <a href="#a14ecc65a069fa2418fe0c5de0e903541">More...</a><br /></td></tr>
<tr class="separator:a14ecc65a069fa2418fe0c5de0e903541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d73694a697faae297afbdb10f7d102"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionAttributesPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aa2d73694a697faae297afbdb10f7d102">getAttributes</a> () const  =0</td></tr>
<tr class="memdesc:aa2d73694a697faae297afbdb10f7d102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="classgemfire_1_1_region_attributes.html" title="Defines attributes for configuring a region. ">RegionAttributes</a> for this region.  <a href="#aa2d73694a697faae297afbdb10f7d102">More...</a><br /></td></tr>
<tr class="separator:aa2d73694a697faae297afbdb10f7d102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1355f41127488ef518da582d539f0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">AttributesMutatorPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a2a1355f41127488ef518da582d539f0c">getAttributesMutator</a> () const  =0</td></tr>
<tr class="memdesc:a2a1355f41127488ef518da582d539f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the a mutator object for changing a subset of the region attributes.  <a href="#a2a1355f41127488ef518da582d539f0c">More...</a><br /></td></tr>
<tr class="separator:a2a1355f41127488ef518da582d539f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5c8d08672c8c97a59555800031f3e1b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">CachePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ac5c8d08672c8c97a59555800031f3e1b">getCache</a> () const  =0</td></tr>
<tr class="memdesc:ac5c8d08672c8c97a59555800031f3e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>cache</code> associated with this region.  <a href="#ac5c8d08672c8c97a59555800031f3e1b">More...</a><br /></td></tr>
<tr class="separator:ac5c8d08672c8c97a59555800031f3e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cfcd52da8cca9eb076b13846f07ff4e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionEntryPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a7cfcd52da8cca9eb076b13846f07ff4e">getEntry</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key)=0</td></tr>
<tr class="memdesc:a7cfcd52da8cca9eb076b13846f07ff4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the meta-object <a class="el" href="classgemfire_1_1_region_entry.html" title="An object in a Region that represents an entry, i.e., a key-value pair. ">RegionEntry</a> for key.  <a href="#a7cfcd52da8cca9eb076b13846f07ff4e">More...</a><br /></td></tr>
<tr class="separator:a7cfcd52da8cca9eb076b13846f07ff4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749d76d742d7a0596d37105e416a7b36"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a749d76d742d7a0596d37105e416a7b36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classgemfire_1_1_shared_ptr.html">RegionEntryPtr</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a749d76d742d7a0596d37105e416a7b36">getEntry</a> (const KEYTYPE &amp;key)</td></tr>
<tr class="memdesc:a749d76d742d7a0596d37105e416a7b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a749d76d742d7a0596d37105e416a7b36">More...</a><br /></td></tr>
<tr class="separator:a749d76d742d7a0596d37105e416a7b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ec7e4de00327e043513be43a11d79c"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a15ec7e4de00327e043513be43a11d79c">getFullPath</a> () const  =0</td></tr>
<tr class="memdesc:a15ec7e4de00327e043513be43a11d79c"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the full path of the region as can be used to lookup the region from <a class="el" href="classgemfire_1_1_cache.html#a41b57e2c8d0cb54bcee5366710eb759c" title="Look up a region with the full path from root. ">Cache::getRegion</a>.  <a href="#a15ec7e4de00327e043513be43a11d79c">More...</a><br /></td></tr>
<tr class="separator:a15ec7e4de00327e043513be43a11d79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac444ff82b2a5f23072e40bc5cccacd95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ac444ff82b2a5f23072e40bc5cccacd95">getInterestList</a> (<a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;vlist) const  =0</td></tr>
<tr class="memdesc:ac444ff82b2a5f23072e40bc5cccacd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of keys on which this client is interested and will be notified of changes.  <a href="#ac444ff82b2a5f23072e40bc5cccacd95">More...</a><br /></td></tr>
<tr class="separator:ac444ff82b2a5f23072e40bc5cccacd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52deea8bbae2af0f9b2cf979590eba9c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a52deea8bbae2af0f9b2cf979590eba9c">getInterestListRegex</a> (<a class="el" href="classgemfire_1_1_vector_t.html">VectorOfCacheableString</a> &amp;vregex) const  =0</td></tr>
<tr class="memdesc:a52deea8bbae2af0f9b2cf979590eba9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of regular expresssions on which this client is interested and will be notified of changes.  <a href="#a52deea8bbae2af0f9b2cf979590eba9c">More...</a><br /></td></tr>
<tr class="separator:a52deea8bbae2af0f9b2cf979590eba9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfb3d4f06b8b5fbd1a216e1f2b77e44"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a6bfb3d4f06b8b5fbd1a216e1f2b77e44">getName</a> () const  =0</td></tr>
<tr class="memdesc:a6bfb3d4f06b8b5fbd1a216e1f2b77e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public Methods.  <a href="#a6bfb3d4f06b8b5fbd1a216e1f2b77e44">More...</a><br /></td></tr>
<tr class="separator:a6bfb3d4f06b8b5fbd1a216e1f2b77e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8eba43979baedbeca16a4ebc316fdd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#afe8eba43979baedbeca16a4ebc316fdd">getParentRegion</a> () const  =0</td></tr>
<tr class="memdesc:afe8eba43979baedbeca16a4ebc316fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the parent region, or NULLPTR if a root region.  <a href="#afe8eba43979baedbeca16a4ebc316fdd">More...</a><br /></td></tr>
<tr class="separator:afe8eba43979baedbeca16a4ebc316fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b148af5a9948223b8f12c9b024068"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionServicePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aac1b148af5a9948223b8f12c9b024068">getRegionService</a> () const  =0</td></tr>
<tr class="memdesc:aac1b148af5a9948223b8f12c9b024068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>cache</code> associated with this region.  <a href="#aac1b148af5a9948223b8f12c9b024068">More...</a><br /></td></tr>
<tr class="separator:aac1b148af5a9948223b8f12c9b024068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887300077216513ae9b979ffdab36983"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a887300077216513ae9b979ffdab36983">getSubregion</a> (const char *path)=0</td></tr>
<tr class="memdesc:a887300077216513ae9b979ffdab36983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the subregion identified by the path, NULLPTR if no such subregion.  <a href="#a887300077216513ae9b979ffdab36983">More...</a><br /></td></tr>
<tr class="separator:a887300077216513ae9b979ffdab36983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695d2a7870358c69d28c3855aa3d7b7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a695d2a7870358c69d28c3855aa3d7b7f">invalidate</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a695d2a7870358c69d28c3855aa3d7b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the entry with the specified key, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>.  <a href="#a695d2a7870358c69d28c3855aa3d7b7f">More...</a><br /></td></tr>
<tr class="separator:a695d2a7870358c69d28c3855aa3d7b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa52b6c638eb1435092ae26f81b8f438c"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:aa52b6c638eb1435092ae26f81b8f438c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aa52b6c638eb1435092ae26f81b8f438c">invalidate</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:aa52b6c638eb1435092ae26f81b8f438c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#aa52b6c638eb1435092ae26f81b8f438c">More...</a><br /></td></tr>
<tr class="separator:aa52b6c638eb1435092ae26f81b8f438c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff62eed9d631e53efcb703d6ffd5789"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#afff62eed9d631e53efcb703d6ffd5789">invalidateRegion</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:afff62eed9d631e53efcb703d6ffd5789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates this region.  <a href="#afff62eed9d631e53efcb703d6ffd5789">More...</a><br /></td></tr>
<tr class="separator:afff62eed9d631e53efcb703d6ffd5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49244bb426dd2d2aa7443e5fed8e229"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ad49244bb426dd2d2aa7443e5fed8e229">keys</a> (<a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;v)=0</td></tr>
<tr class="memdesc:ad49244bb426dd2d2aa7443e5fed8e229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all the keys in the local process for this region.  <a href="#ad49244bb426dd2d2aa7443e5fed8e229">More...</a><br /></td></tr>
<tr class="separator:ad49244bb426dd2d2aa7443e5fed8e229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29bdbee2d679e08b57c464b1eb652a96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a29bdbee2d679e08b57c464b1eb652a96">localClear</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a29bdbee2d679e08b57c464b1eb652a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> invoked in the process.  <a href="#a29bdbee2d679e08b57c464b1eb652a96">More...</a><br /></td></tr>
<tr class="separator:a29bdbee2d679e08b57c464b1eb652a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c32c65195cf7fb1825536b8e3239f7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a7c32c65195cf7fb1825536b8e3239f7b">localCreate</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a7c32c65195cf7fb1825536b8e3239f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new entry in this region with the specified key and value in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a7c32c65195cf7fb1825536b8e3239f7b">More...</a><br /></td></tr>
<tr class="separator:a7c32c65195cf7fb1825536b8e3239f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaa519382aed2a71792438e3d102ed3"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:aaaaa519382aed2a71792438e3d102ed3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aaaaa519382aed2a71792438e3d102ed3">localCreate</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:aaaaa519382aed2a71792438e3d102ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#aaaaa519382aed2a71792438e3d102ed3">More...</a><br /></td></tr>
<tr class="separator:aaaaa519382aed2a71792438e3d102ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd4ac270dedebee70702f0b60f78cc8"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:aacd4ac270dedebee70702f0b60f78cc8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aacd4ac270dedebee70702f0b60f78cc8">localCreate</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:aacd4ac270dedebee70702f0b60f78cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#aacd4ac270dedebee70702f0b60f78cc8">More...</a><br /></td></tr>
<tr class="separator:aacd4ac270dedebee70702f0b60f78cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc578252730b0873def92c02775d14b8"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:acc578252730b0873def92c02775d14b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#acc578252730b0873def92c02775d14b8">localCreate</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:acc578252730b0873def92c02775d14b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#acc578252730b0873def92c02775d14b8">More...</a><br /></td></tr>
<tr class="separator:acc578252730b0873def92c02775d14b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f6d0138450902a0e3cba228edbd48a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a88f6d0138450902a0e3cba228edbd48a">localDestroy</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a88f6d0138450902a0e3cba228edbd48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a88f6d0138450902a0e3cba228edbd48a">More...</a><br /></td></tr>
<tr class="separator:a88f6d0138450902a0e3cba228edbd48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901a51887d8339b159a6da2526c1970a"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a901a51887d8339b159a6da2526c1970a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a901a51887d8339b159a6da2526c1970a">localDestroy</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a901a51887d8339b159a6da2526c1970a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a901a51887d8339b159a6da2526c1970a">More...</a><br /></td></tr>
<tr class="separator:a901a51887d8339b159a6da2526c1970a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad8b7c842587d3a463bc6f42de13e0d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a4ad8b7c842587d3a463bc6f42de13e0d">localDestroyRegion</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a4ad8b7c842587d3a463bc6f42de13e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a4ad8b7c842587d3a463bc6f42de13e0d">More...</a><br /></td></tr>
<tr class="separator:a4ad8b7c842587d3a463bc6f42de13e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd95f37c13a7cc49f5725feb782ba8c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a6fd95f37c13a7cc49f5725feb782ba8c">localInvalidate</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a6fd95f37c13a7cc49f5725feb782ba8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates the entry with the specified key in the local cache only, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>.  <a href="#a6fd95f37c13a7cc49f5725feb782ba8c">More...</a><br /></td></tr>
<tr class="separator:a6fd95f37c13a7cc49f5725feb782ba8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d3d87c6f98995d62340bcc425cfb85"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ab8d3d87c6f98995d62340bcc425cfb85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ab8d3d87c6f98995d62340bcc425cfb85">localInvalidate</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:ab8d3d87c6f98995d62340bcc425cfb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#ab8d3d87c6f98995d62340bcc425cfb85">More...</a><br /></td></tr>
<tr class="separator:ab8d3d87c6f98995d62340bcc425cfb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af033850fdf85930b496ee41d306e0b19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#af033850fdf85930b496ee41d306e0b19">localInvalidateRegion</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:af033850fdf85930b496ee41d306e0b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalidates this region.  <a href="#af033850fdf85930b496ee41d306e0b19">More...</a><br /></td></tr>
<tr class="separator:af033850fdf85930b496ee41d306e0b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4326132930e9222a31ad9a1f56f1e5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ab4326132930e9222a31ad9a1f56f1e5a">localPut</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:ab4326132930e9222a31ad9a1f56f1e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a new value into an entry in this region with the specified key in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#ab4326132930e9222a31ad9a1f56f1e5a">More...</a><br /></td></tr>
<tr class="separator:ab4326132930e9222a31ad9a1f56f1e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435c1b09500e647f7f71812a6a7d5b67"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a435c1b09500e647f7f71812a6a7d5b67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a435c1b09500e647f7f71812a6a7d5b67">localPut</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a435c1b09500e647f7f71812a6a7d5b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a435c1b09500e647f7f71812a6a7d5b67">More...</a><br /></td></tr>
<tr class="separator:a435c1b09500e647f7f71812a6a7d5b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e22d89810f1c11f2fe8476b292b56c"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ae8e22d89810f1c11f2fe8476b292b56c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ae8e22d89810f1c11f2fe8476b292b56c">localPut</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:ae8e22d89810f1c11f2fe8476b292b56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#ae8e22d89810f1c11f2fe8476b292b56c">More...</a><br /></td></tr>
<tr class="separator:ae8e22d89810f1c11f2fe8476b292b56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a1111258f42b32da0809727a6d4954"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:ae2a1111258f42b32da0809727a6d4954"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ae2a1111258f42b32da0809727a6d4954">localPut</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:ae2a1111258f42b32da0809727a6d4954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#ae2a1111258f42b32da0809727a6d4954">More...</a><br /></td></tr>
<tr class="separator:ae2a1111258f42b32da0809727a6d4954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5cd3bd2243440983f3fba8daed2aaa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aae5cd3bd2243440983f3fba8daed2aaa">localRemove</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:aae5cd3bd2243440983f3fba8daed2aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key and value in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#aae5cd3bd2243440983f3fba8daed2aaa">More...</a><br /></td></tr>
<tr class="separator:aae5cd3bd2243440983f3fba8daed2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078430890a8f8e076e41517c00fbed1a"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a078430890a8f8e076e41517c00fbed1a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a078430890a8f8e076e41517c00fbed1a">localRemove</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a078430890a8f8e076e41517c00fbed1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a078430890a8f8e076e41517c00fbed1a">More...</a><br /></td></tr>
<tr class="separator:a078430890a8f8e076e41517c00fbed1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be0122aac95491e758609aef1a3ed3d"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a6be0122aac95491e758609aef1a3ed3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a6be0122aac95491e758609aef1a3ed3d">localRemove</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a6be0122aac95491e758609aef1a3ed3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a6be0122aac95491e758609aef1a3ed3d">More...</a><br /></td></tr>
<tr class="separator:a6be0122aac95491e758609aef1a3ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e39b02864f041d1e49614fa0e7e6f66"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:a7e39b02864f041d1e49614fa0e7e6f66"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a7e39b02864f041d1e49614fa0e7e6f66">localRemove</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a7e39b02864f041d1e49614fa0e7e6f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#a7e39b02864f041d1e49614fa0e7e6f66">More...</a><br /></td></tr>
<tr class="separator:a7e39b02864f041d1e49614fa0e7e6f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53889ab65787669cc437066f4199000f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a53889ab65787669cc437066f4199000f">localRemoveEx</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a53889ab65787669cc437066f4199000f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a53889ab65787669cc437066f4199000f">More...</a><br /></td></tr>
<tr class="separator:a53889ab65787669cc437066f4199000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1bf71128966478b48e16c5dfe9ee29"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:afa1bf71128966478b48e16c5dfe9ee29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#afa1bf71128966478b48e16c5dfe9ee29">localRemoveEx</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:afa1bf71128966478b48e16c5dfe9ee29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#afa1bf71128966478b48e16c5dfe9ee29">More...</a><br /></td></tr>
<tr class="separator:afa1bf71128966478b48e16c5dfe9ee29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327be04b1f16b21a84b654e62c8cb047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_shared_base.html#a327be04b1f16b21a84b654e62c8cb047">preserveSB</a> () const </td></tr>
<tr class="memdesc:a327be04b1f16b21a84b654e62c8cb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically increment reference count.  <a href="#a327be04b1f16b21a84b654e62c8cb047">More...</a><br /></td></tr>
<tr class="separator:a327be04b1f16b21a84b654e62c8cb047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c7bf2eb5d466fa3f5dfa6f9b8d392"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aca7c7bf2eb5d466fa3f5dfa6f9b8d392">put</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:aca7c7bf2eb5d466fa3f5dfa6f9b8d392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a new value into an entry in this region with the specified key, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#aca7c7bf2eb5d466fa3f5dfa6f9b8d392">More...</a><br /></td></tr>
<tr class="separator:aca7c7bf2eb5d466fa3f5dfa6f9b8d392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1394ea4f20da5c42d52a5acd7aa62815"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:a1394ea4f20da5c42d52a5acd7aa62815"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a1394ea4f20da5c42d52a5acd7aa62815">put</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a1394ea4f20da5c42d52a5acd7aa62815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#a1394ea4f20da5c42d52a5acd7aa62815">More...</a><br /></td></tr>
<tr class="separator:a1394ea4f20da5c42d52a5acd7aa62815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ed32cff76c8fa62654bcc6a70e1ace"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a18ed32cff76c8fa62654bcc6a70e1ace"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a18ed32cff76c8fa62654bcc6a70e1ace">put</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a18ed32cff76c8fa62654bcc6a70e1ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a18ed32cff76c8fa62654bcc6a70e1ace">More...</a><br /></td></tr>
<tr class="separator:a18ed32cff76c8fa62654bcc6a70e1ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39f20f36b8dbb95c46aa19dd9b1d63e"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:ab39f20f36b8dbb95c46aa19dd9b1d63e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ab39f20f36b8dbb95c46aa19dd9b1d63e">put</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:ab39f20f36b8dbb95c46aa19dd9b1d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#ab39f20f36b8dbb95c46aa19dd9b1d63e">More...</a><br /></td></tr>
<tr class="separator:ab39f20f36b8dbb95c46aa19dd9b1d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a7d08dccc68bbea42a0e27aee9cf2e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a73a7d08dccc68bbea42a0e27aee9cf2e">putAll</a> (const <a class="el" href="classgemfire_1_1_hash_map_of_cacheable.html">HashMapOfCacheable</a> &amp;map, uint32_t timeout=15, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a73a7d08dccc68bbea42a0e27aee9cf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places a set of new values in this region with the specified keys given as a map of key/value pairs.  <a href="#a73a7d08dccc68bbea42a0e27aee9cf2e">More...</a><br /></td></tr>
<tr class="separator:a73a7d08dccc68bbea42a0e27aee9cf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c3e653c2b6634a2a27de668cf3f7d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">SelectResultsPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a60c3e653c2b6634a2a27de668cf3f7d0">query</a> (const char *predicate, uint32_t timeout=<a class="el" href="gf__base_8hpp.html#a3652aa8957738101aa9d01b236305604">DEFAULT_QUERY_RESPONSE_TIMEOUT</a>)=0</td></tr>
<tr class="memdesc:a60c3e653c2b6634a2a27de668cf3f7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the query on the server based on the predicate.  <a href="#a60c3e653c2b6634a2a27de668cf3f7d0">More...</a><br /></td></tr>
<tr class="separator:a60c3e653c2b6634a2a27de668cf3f7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197c0b015e8fa9656ea520a0fbd57008"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_shared_base.html#a197c0b015e8fa9656ea520a0fbd57008">refCount</a> ()</td></tr>
<tr class="separator:a197c0b015e8fa9656ea520a0fbd57008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40219e26a13978054c203024af365f71"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a40219e26a13978054c203024af365f71">registerAllKeys</a> (bool isDurable=false, <a class="el" href="classgemfire_1_1_shared_ptr.html">VectorOfCacheableKeyPtr</a> resultKeys=gemfire::NullSharedBase::s_instancePtr, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>
<tr class="memdesc:a40219e26a13978054c203024af365f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers to get updates for all keys from the server.  <a href="#a40219e26a13978054c203024af365f71">More...</a><br /></td></tr>
<tr class="separator:a40219e26a13978054c203024af365f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac068483783251bdcbedb3e4f7e5071dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ac068483783251bdcbedb3e4f7e5071dd">registerKeys</a> (const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;<a class="el" href="classgemfire_1_1_region.html#ad49244bb426dd2d2aa7443e5fed8e229">keys</a>, bool isDurable=false, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>
<tr class="memdesc:ac068483783251bdcbedb3e4f7e5071dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an array of keys for getting updates from the server.  <a href="#ac068483783251bdcbedb3e4f7e5071dd">More...</a><br /></td></tr>
<tr class="separator:ac068483783251bdcbedb3e4f7e5071dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd438bc24e6007094a3833c7ddf7cab4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#abd438bc24e6007094a3833c7ddf7cab4">registerRegex</a> (const char *regex, bool isDurable=false, <a class="el" href="classgemfire_1_1_shared_ptr.html">VectorOfCacheableKeyPtr</a> resultKeys=gemfire::NullSharedBase::s_instancePtr, bool getInitialValues=false, bool receiveValues=true)=0</td></tr>
<tr class="memdesc:abd438bc24e6007094a3833c7ddf7cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a regular expression to match with keys to get updates from the server.  <a href="#abd438bc24e6007094a3833c7ddf7cab4">More...</a><br /></td></tr>
<tr class="separator:abd438bc24e6007094a3833c7ddf7cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44da117cf90615f1302a5a70b5eb9d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_shared_base.html#a44da117cf90615f1302a5a70b5eb9d91">releaseSB</a> () const </td></tr>
<tr class="memdesc:a44da117cf90615f1302a5a70b5eb9d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomically decrement reference count, the <a class="el" href="classgemfire_1_1_shared_base.html" title="This abstract base class is the base class of all user objects that have the shared capability of ref...">SharedBase</a> object is automatically deleted when its reference count goes to zero.  <a href="#a44da117cf90615f1302a5a70b5eb9d91">More...</a><br /></td></tr>
<tr class="separator:a44da117cf90615f1302a5a70b5eb9d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759e15064bcccf16e898a8de8502851e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a759e15064bcccf16e898a8de8502851e">remove</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a759e15064bcccf16e898a8de8502851e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key, value and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a759e15064bcccf16e898a8de8502851e">More...</a><br /></td></tr>
<tr class="separator:a759e15064bcccf16e898a8de8502851e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a82b5a6f2c680cdb220587ce526ce7"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE , class VALUETYPE &gt; </td></tr>
<tr class="memitem:ad3a82b5a6f2c680cdb220587ce526ce7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ad3a82b5a6f2c680cdb220587ce526ce7">remove</a> (const KEYTYPE &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:ad3a82b5a6f2c680cdb220587ce526ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#ad3a82b5a6f2c680cdb220587ce526ce7">More...</a><br /></td></tr>
<tr class="separator:ad3a82b5a6f2c680cdb220587ce526ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af725edc4a00f5c6ba756dcb813fba9e8"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:af725edc4a00f5c6ba756dcb813fba9e8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#af725edc4a00f5c6ba756dcb813fba9e8">remove</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:af725edc4a00f5c6ba756dcb813fba9e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#af725edc4a00f5c6ba756dcb813fba9e8">More...</a><br /></td></tr>
<tr class="separator:af725edc4a00f5c6ba756dcb813fba9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb922e6630e184e6a7b115ddaa423cd9"><td class="memTemplParams" colspan="2">template&lt;class VALUETYPE &gt; </td></tr>
<tr class="memitem:acb922e6630e184e6a7b115ddaa423cd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#acb922e6630e184e6a7b115ddaa423cd9">remove</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const VALUETYPE &amp;value, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:acb922e6630e184e6a7b115ddaa423cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing value to be a const char*.  <a href="#acb922e6630e184e6a7b115ddaa423cd9">More...</a><br /></td></tr>
<tr class="separator:acb922e6630e184e6a7b115ddaa423cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fd371695f56106874541c17c27b6a3"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:ad7fd371695f56106874541c17c27b6a3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ad7fd371695f56106874541c17c27b6a3">remove</a> (const KEYTYPE &amp;key)</td></tr>
<tr class="memdesc:ad7fd371695f56106874541c17c27b6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing both key and value to be a const char*.  <a href="#ad7fd371695f56106874541c17c27b6a3">More...</a><br /></td></tr>
<tr class="separator:ad7fd371695f56106874541c17c27b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b325cd1c41cd75bdeb8e97b93312a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a54b325cd1c41cd75bdeb8e97b93312a9">removeAll</a> (const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;<a class="el" href="classgemfire_1_1_region.html#ad49244bb426dd2d2aa7443e5fed8e229">keys</a>, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a54b325cd1c41cd75bdeb8e97b93312a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all of the entries for the specified keys from this region.  <a href="#a54b325cd1c41cd75bdeb8e97b93312a9">More...</a><br /></td></tr>
<tr class="separator:a54b325cd1c41cd75bdeb8e97b93312a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c49ed8cd8ed88625ccad3791416590c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a5c49ed8cd8ed88625ccad3791416590c">removeEx</a> (const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;aCallbackArgument=gemfire::NullSharedBase::s_instancePtr)=0</td></tr>
<tr class="memdesc:a5c49ed8cd8ed88625ccad3791416590c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the entry with the specified key and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process.  <a href="#a5c49ed8cd8ed88625ccad3791416590c">More...</a><br /></td></tr>
<tr class="separator:a5c49ed8cd8ed88625ccad3791416590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4022b73e01f4f22bcba6a5bbc9e12dcc"><td class="memTemplParams" colspan="2">template&lt;class KEYTYPE &gt; </td></tr>
<tr class="memitem:a4022b73e01f4f22bcba6a5bbc9e12dcc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a4022b73e01f4f22bcba6a5bbc9e12dcc">removeEx</a> (const KEYTYPE &amp;key, const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;arg=gemfire::NullSharedBase::s_instancePtr)</td></tr>
<tr class="memdesc:a4022b73e01f4f22bcba6a5bbc9e12dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method allowing key to be a const char*.  <a href="#a4022b73e01f4f22bcba6a5bbc9e12dcc">More...</a><br /></td></tr>
<tr class="separator:a4022b73e01f4f22bcba6a5bbc9e12dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed8c623fb3cec5e5574348c268e581"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">SerializablePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a2aed8c623fb3cec5e5574348c268e581">selectValue</a> (const char *predicate, uint32_t timeout=<a class="el" href="gf__base_8hpp.html#a3652aa8957738101aa9d01b236305604">DEFAULT_QUERY_RESPONSE_TIMEOUT</a>)=0</td></tr>
<tr class="memdesc:a2aed8c623fb3cec5e5574348c268e581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the query on the server based on the predicate and returns a single result value.  <a href="#a2aed8c623fb3cec5e5574348c268e581">More...</a><br /></td></tr>
<tr class="separator:a2aed8c623fb3cec5e5574348c268e581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0429277fb24eb3e7401dae91a699155"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#ab0429277fb24eb3e7401dae91a699155">serverKeys</a> (<a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;v)=0</td></tr>
<tr class="memdesc:ab0429277fb24eb3e7401dae91a699155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the set of keys defined in the server process associated to this client and region.  <a href="#ab0429277fb24eb3e7401dae91a699155">More...</a><br /></td></tr>
<tr class="separator:ab0429277fb24eb3e7401dae91a699155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5936a627a93153f6d6be7af1c41a4b49"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a5936a627a93153f6d6be7af1c41a4b49">size</a> ()=0</td></tr>
<tr class="memdesc:a5936a627a93153f6d6be7af1c41a4b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of region.  <a href="#a5936a627a93153f6d6be7af1c41a4b49">More...</a><br /></td></tr>
<tr class="separator:a5936a627a93153f6d6be7af1c41a4b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad82433371c15d619b88baa8b35903e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#aaad82433371c15d619b88baa8b35903e">subregions</a> (const bool recursive, <a class="el" href="classgemfire_1_1_vector_t.html">VectorOfRegion</a> &amp;sr)=0</td></tr>
<tr class="memdesc:aaad82433371c15d619b88baa8b35903e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates the passed in VectorOfRegion with subregions of the current region.  <a href="#aaad82433371c15d619b88baa8b35903e">More...</a><br /></td></tr>
<tr class="separator:aaad82433371c15d619b88baa8b35903e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93608329f29a824fa78fa0ecc20de9b6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a93608329f29a824fa78fa0ecc20de9b6">unregisterAllKeys</a> ()=0</td></tr>
<tr class="memdesc:a93608329f29a824fa78fa0ecc20de9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers to get updates for all keys from the server.  <a href="#a93608329f29a824fa78fa0ecc20de9b6">More...</a><br /></td></tr>
<tr class="separator:a93608329f29a824fa78fa0ecc20de9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed1c18d8b7ed87f89a26e8199b09f32"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a2ed1c18d8b7ed87f89a26e8199b09f32">unregisterKeys</a> (const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;<a class="el" href="classgemfire_1_1_region.html#ad49244bb426dd2d2aa7443e5fed8e229">keys</a>)=0</td></tr>
<tr class="memdesc:a2ed1c18d8b7ed87f89a26e8199b09f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an array of keys to stop getting updates for them.  <a href="#a2ed1c18d8b7ed87f89a26e8199b09f32">More...</a><br /></td></tr>
<tr class="separator:a2ed1c18d8b7ed87f89a26e8199b09f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fdcf25dc377ca43544ee1cacd241cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a21fdcf25dc377ca43544ee1cacd241cd">unregisterRegex</a> (const char *regex)=0</td></tr>
<tr class="memdesc:a21fdcf25dc377ca43544ee1cacd241cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a regular expression to stop getting updates for keys from the server.  <a href="#a21fdcf25dc377ca43544ee1cacd241cd">More...</a><br /></td></tr>
<tr class="separator:a21fdcf25dc377ca43544ee1cacd241cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d25cce2f2fcff0ba37e3f8f43c345b1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgemfire_1_1_region.html#a7d25cce2f2fcff0ba37e3f8f43c345b1">values</a> (<a class="el" href="classgemfire_1_1_vector_of_cacheable.html">VectorOfCacheable</a> &amp;vc)=0</td></tr>
<tr class="memdesc:a7d25cce2f2fcff0ba37e3f8f43c345b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all values in the local process for this region.  <a href="#a7d25cce2f2fcff0ba37e3f8f43c345b1">More...</a><br /></td></tr>
<tr class="separator:a7d25cce2f2fcff0ba37e3f8f43c345b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class manages subregions and cached data. </p>
<p>Each region can contain multiple subregions and entries for data. Regions provide a hierachical name space within the cache. Also, a region can be used to group cached objects for management purposes.</p>
<p>Entries managed by the region are key-value pairs. A set of region attributes is associated with the region when it is created.</p>
<p>The <a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a> interface basically contains two set of APIs: <a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a> management APIs and (potentially) distributed operations on entries. Non-distributed operations on entries are provided by <code><a class="el" href="classgemfire_1_1_region_entry.html" title="An object in a Region that represents an entry, i.e., a key-value pair. ">RegionEntry</a></code>.</p>
<p>Each <code><a class="el" href="classgemfire_1_1_cache.html" title="Cache are obtained from create method on the CacheFactory#create class. ">Cache</a></code> defines regions called the root regions. User applications can use the root regions to create subregions for isolated name space and object grouping.</p>
<p>A region's name can be any String, except that it should not contain the region name separator, a forward slash (/).</p>
<p><code>Regions</code> can be referenced by a relative path name from any region higher in the hierarchy in <a class="el" href="classgemfire_1_1_region.html#a887300077216513ae9b979ffdab36983">Region::getSubregion</a>. You can get the relative path from the root region with <a class="el" href="classgemfire_1_1_region.html#a15ec7e4de00327e043513be43a11d79c">Region::getFullPath</a>. The name separator is used to concatenate all the region names together from the root, starting with the root's subregions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region_attributes.html" title="Defines attributes for configuring a region. ">RegionAttributes</a> </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad84d7304ac66099bddfcb367e064ac61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> invoked in the process. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_cache_listener.html#a6d3950520d80578a3bcd1d142b4ec094" title="Handles the event of a region being cleared. ">CacheListener::afterRegionClear</a> </dd>
<dd>
CacheWriter::beforeRegionClear </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb7477fa661a96f1b6a6fd51f815825"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::containsKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only the client's cache is searched for the key. </p>
<p>It does not go to the java server to which it is connected with. </p>

</div>
</div>
<a class="anchor" id="a769fd54be4a0ee7a672a634cce347254"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::containsKey </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char* This operations checks for the key in the local cache . </p>
<p>It is not propagated to the Gemfire cache server to which it is connected. </p>

</div>
</div>
<a class="anchor" id="a0cbd42ce77bb58c3d515de21ad6c1da7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::containsKeyOnServer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The cache of the server, to which it is connected with, is searched for the key to see if the key is present. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the region's scope is <a class="el" href="classgemfire_1_1_scope_type.html#aa30074e46fcb3e571974f60fe95a495aa78b77e65de9646e73d76291bc9087751" title="no distribution. ">ScopeType::LOCAL</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa6d2ce760fa976ae4ec7d7a5ac8fe91c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::containsValueForKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>keyPtr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operations checks for the value in the local cache . </p>
<p>It is not propagated to the Gemfire cache server to which it is connected. </p>

</div>
</div>
<a class="anchor" id="ab50011f336b4f2257fb66982c6e2b1b1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::containsValueForKey </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char* This operations checks for the value in the local cache . </p>
<p>It is not propagated to the Gemfire cache server to which it is connected. </p>

</div>
</div>
<a class="anchor" id="aecb3c05a5fa94a1950a9fb2cb90ec5eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new entry in this region with the specified key and value, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. The new entry is propogated to the java server also to which it is connected with. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<p>If remote server put fails throwing back a <code>CacheServerException</code> or security exception, then local put is tried to rollback. However, if the entry has overflowed/evicted/expired then the rollback is aborted since it may be due to a more recent notification or update by another thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key smart pointer for which to create the entry in this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value for the new entry, which may be NULLPTR meaning the new entry starts as if it had been locally invalidated. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR or if the key, value, or aCallbackArgument do not meet serializability requirements </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if region is no longer valid </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if the operation timed out </td></tr>
    <tr><td class="paramname">OutOfMemoryException</td><td>if no memory for new entry </td></tr>
    <tr><td class="paramname">EntryExistsException</td><td>if an entry with this key already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a054c1dbb45e8d3c824c8f38d2255e08e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::create </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a4ccfdcf0e0d35711f18e87401a48b326"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::create </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a2324fe6f8effeabf001475d1469f9ffc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a4b66d56b2d0074be11e82c877fbd2180"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionPtr</a> gemfire::Region::createSubregion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subregionName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionAttributesPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aRegionAttributes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a subregion with the specified attributes. </p>

</div>
</div>
<a class="anchor" id="a41dd235083a3f598869ff5331a2b194e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::destroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the entry with the specified key, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. Destroy removes not only the value, but also the key and entry from this region.</p>
<p>The destroy is propogated to the Gemfire cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code>CacheServerException</code> or security exception, then the local entry is still destroyed.</p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to destroy </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if the operation timed out </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is destroyed. </td></tr>
    <tr><td class="paramname">EntryNotFoundException</td><td>if the entry does not exist in this region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a695d2a7870358c69d28c3855aa3d7b7f" title="Invalidates the entry with the specified key, and provides a user-defined argument to the CacheListen...">invalidate</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed. ">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_writer.html#a73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed. ">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a845f81574d338fd7d82331ed54ebb59b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::destroy </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a2b07a940ee17e375c45421e85b27a8ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::destroyRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>Destroy cascades to all entries and subregions. After the destroy, this region object cannot be used any more. Any attempt to use this region object will get a <code>RegionDestroyedException</code> exception.</p>
<p>The region destroy not only destroys the local region but also destroys the server region. However, if server region destroy fails throwing back <code>CacheServerException</code> or security exception, the local region is still destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this call. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation; if this occurs some subregions may have already been successfully destroyed. </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if not connected to the gemfire system because the client cannot establish usable connections to any of the servers given to it. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#afff62eed9d631e53efcb703d6ffd5789" title="Invalidates this region. ">invalidateRegion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70a6aca22412dc1e5ea1645866d4ed3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::existsValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="gf__base_8hpp.html#a3652aa8957738101aa9d01b236305604">DEFAULT_QUERY_RESPONSE_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the query on the server based on the predicate and returns whether any result exists. </p>
<p>Valid only for a Native Client region. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time (in seconds) to wait for the response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If predicate is empty or timeout parameter is greater than 2^31/1000. </td></tr>
    <tr><td class="paramname">QueryException</td><td>if some query error occurred at the server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when the reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
    <tr><td class="paramname">CacheClosedException</td><td>if the cache has been closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the result size is non-zero, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6417a042b32bba4bd39011dc5909f4c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> gemfire::Region::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value associated with the specified key, passing the callback argument to any cache loaders that are invoked in the operation. </p>
<p>If the value is not present locally then it is requested from the java server. If even that is unsuccessful then a local <a class="el" href="classgemfire_1_1_cache_loader.html" title="An application plug-in that can be installed on a region. ">CacheLoader</a> will be invoked if there is one. The value returned by get is not copied, so multi-threaded applications should not modify the value directly, but should use the update methods. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a>, <a class="el" href="">CacheStatistics::getHitCount</a>, <a class="el" href="">CacheStatistics::getMissCount</a>, and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> (if a new value is loaded) for this region and the entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>whose associated value is to be returned. The key Object must implement the equals and hashCode methods. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument passed into the <a class="el" href="classgemfire_1_1_cache_loader.html" title="An application plug-in that can be installed on a region. ">CacheLoader</a> if loader is used. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR or aCallbackArgument is not serializable and a remote <a class="el" href="classgemfire_1_1_cache_loader.html" title="An application plug-in that can be installed on a region. ">CacheLoader</a> needs to be invoked </td></tr>
    <tr><td class="paramname">CacheLoaderException</td><td>if <a class="el" href="classgemfire_1_1_cache_loader.html" title="An application plug-in that can be installed on a region. ">CacheLoader</a> throws an exception </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the method is called on a destroyed region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ac63871ceb4380d41b5963afe3001c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> gemfire::Region::get </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>callbackArg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a14ecc65a069fa2418fe0c5de0e903541"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::getAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_shared_ptr.html">HashMapOfCacheablePtr</a>&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_shared_ptr.html">HashMapOfExceptionPtr</a>&#160;</td>
          <td class="paramname"><em>exceptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addToLocalCache</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets values for an array of keys from the local cache or server. </p>
<p>If value for a key is not present locally then it is requested from the java server. The value returned is not copied, so multi-threaded applications should not modify the value directly, but should use the update methods. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a>, <a class="el" href="">CacheStatistics::getHitCount</a> and <a class="el" href="">CacheStatistics::getMissCount</a> for this region and the entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the array of keys </td></tr>
    <tr><td class="paramname">values</td><td>Output parameter that provides the map of keys to respective values. It is ignored if NULLPTR, and when NULLPTR then at least the <code>addToLocalCache</code> parameter should be true and caching should be enabled for the region to get values into the region otherwise an <code>IllegalArgumentException</code> is thrown. </td></tr>
    <tr><td class="paramname">exceptions</td><td>Output parameter that provides the map of keys to any exceptions while obtaining the key. It is ignored if NULLPTR. </td></tr>
    <tr><td class="paramname">addToLocalCache</td><td>true if the obtained values have also to be added to the local cache </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>8.1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions. It may be NULLPTR. Must be serializable if this operation is distributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If the array of keys is empty. Other invalid case is when the <code>values</code> parameter is NULLPTR, and either <code>addToLocalCache</code> is false or caching is disabled for this region. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server while processing the request. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the given servers For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a6417a042b32bba4bd39011dc5909f4c1" title="Returns the value associated with the specified key, passing the callback argument to any cache loade...">get</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d73694a697faae297afbdb10f7d102"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionAttributesPtr</a> gemfire::Region::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the <a class="el" href="classgemfire_1_1_region_attributes.html" title="Defines attributes for configuring a region. ">RegionAttributes</a> for this region. </p>

</div>
</div>
<a class="anchor" id="a2a1355f41127488ef518da582d539f0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">AttributesMutatorPtr</a> gemfire::Region::getAttributesMutator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the a mutator object for changing a subset of the region attributes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RegionDestroyedException.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5c8d08672c8c97a59555800031f3e1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">CachePtr</a> gemfire::Region::getCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>cache</code> associated with this region. </p>
<dl class="section return"><dt>Returns</dt><dd>the cache </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>as of NativeClient 3.5, use <a class="el" href="classgemfire_1_1_region.html#aac1b148af5a9948223b8f12c9b024068">Region#getRegionService</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a7cfcd52da8cca9eb076b13846f07ff4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionEntryPtr</a> gemfire::Region::getEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the meta-object <a class="el" href="classgemfire_1_1_region_entry.html" title="An object in a Region that represents an entry, i.e., a key-value pair. ">RegionEntry</a> for key. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException,RegionDestroyedException.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a749d76d742d7a0596d37105e416a7b36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgemfire_1_1_shared_ptr.html">RegionEntryPtr</a> gemfire::Region::getEntry </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a15ec7e4de00327e043513be43a11d79c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* gemfire::Region::getFullPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the full path of the region as can be used to lookup the region from <a class="el" href="classgemfire_1_1_cache.html#a41b57e2c8d0cb54bcee5366710eb759c" title="Look up a region with the full path from root. ">Cache::getRegion</a>. </p>
<p>The storage is backed by the region. </p>

</div>
</div>
<a class="anchor" id="ac444ff82b2a5f23072e40bc5cccacd95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::getInterestList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>vlist</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of keys on which this client is interested and will be notified of changes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the region's scope is <a class="el" href="classgemfire_1_1_scope_type.html#aa30074e46fcb3e571974f60fe95a495aa78b77e65de9646e73d76291bc9087751" title="no distribution. ">ScopeType::LOCAL</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52deea8bbae2af0f9b2cf979590eba9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::getInterestListRegex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_vector_t.html">VectorOfCacheableString</a> &amp;&#160;</td>
          <td class="paramname"><em>vregex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the list of regular expresssions on which this client is interested and will be notified of changes. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the region's scope is <a class="el" href="classgemfire_1_1_scope_type.html#aa30074e46fcb3e571974f60fe95a495aa78b77e65de9646e73d76291bc9087751" title="no distribution. ">ScopeType::LOCAL</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bfb3d4f06b8b5fbd1a216e1f2b77e44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* gemfire::Region::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Public Methods. </p>
<p>return single name of region. The storage is backed by the region. </p>

</div>
</div>
<a class="anchor" id="afe8eba43979baedbeca16a4ebc316fdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionPtr</a> gemfire::Region::getParentRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the parent region, or NULLPTR if a root region. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RegionDestroyedException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aac1b148af5a9948223b8f12c9b024068"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionServicePtr</a> gemfire::Region::getRegionService </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>cache</code> associated with this region. </p>
<dl class="section return"><dt>Returns</dt><dd>the cache </dd></dl>

</div>
</div>
<a class="anchor" id="a887300077216513ae9b979ffdab36983"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">RegionPtr</a> gemfire::Region::getSubregion </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the subregion identified by the path, NULLPTR if no such subregion. </p>

</div>
</div>
<a class="anchor" id="a695d2a7870358c69d28c3855aa3d7b7f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::invalidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the entry with the specified key, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>. </p>
<p>Invalidate only removes the value from the entry, the key is kept intact. To completely remove the entry, destroy should be used. The invalidate is not propogated to the Gemfire cache server to which it is connected with. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the value to be invalidated </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">EntryNotFoundException</td><td>if this entry does not exist in this region locally </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a20d40355842f92cf63c8f64b1bb86aa0" title="Handles the event of an entry&#39;s value being invalidated. ">CacheListener::afterInvalidate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa52b6c638eb1435092ae26f81b8f438c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::invalidate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="afff62eed9d631e53efcb703d6ffd5789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::invalidateRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates this region. </p>
<p>The invalidation will cascade to all the subregions and cached entries. After the <code>invalidateRegion</code> , the region and the entries in it still exist. In order to remove all the entries and the region, <code>destroyRegion</code> should be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is no longer valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a2b07a940ee17e375c45421e85b27a8ff" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter invoked in ...">destroyRegion</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#ad23f60ed056fb03912191092eef29a62" title="Handles the event of a region being invalidated. ">CacheListener::afterRegionInvalidate</a> This operation is not distributed. </dd></dl>

</div>
</div>
<a class="anchor" id="ad49244bb426dd2d2aa7443e5fed8e229"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all the keys in the local process for this region. </p>
<p>This includes keys for which the entry is invalid. </p>

</div>
</div>
<a class="anchor" id="a29bdbee2d679e08b57c464b1eb652a96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localClear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all entries from this region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> or <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> invoked in the process. </p>
<p>Clear will not be distributed to other caches. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_cache_listener.html#a6d3950520d80578a3bcd1d142b4ec094" title="Handles the event of a region being cleared. ">CacheListener::afterRegionClear</a> </dd>
<dd>
CacheWriter::beforeRegionClear </dd></dl>

</div>
</div>
<a class="anchor" id="a7c32c65195cf7fb1825536b8e3239f7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new entry in this region with the specified key and value in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key smart pointer for which to create the entry in this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value for the new entry, which may be NULLPTR meaning the new entry starts as if it had been locally invalidated. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key or value is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if region is no longer valid </td></tr>
    <tr><td class="paramname">OutOfMemoryException</td><td>if no memory for new entry </td></tr>
    <tr><td class="paramname">EntryExistsException</td><td>if an entry with this key already exists </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaaa519382aed2a71792438e3d102ed3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="aacd4ac270dedebee70702f0b60f78cc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="acc578252730b0873def92c02775d14b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localCreate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a88f6d0138450902a0e3cba228edbd48a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localDestroy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. Destroy removes not only the value but also the key and entry from this region. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to destroy. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>the callback for user to pass in, default is NULLPTR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">EntryNotFoundException</td><td>if the entry does not exist in this region locally </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a695d2a7870358c69d28c3855aa3d7b7f" title="Invalidates the entry with the specified key, and provides a user-defined argument to the CacheListen...">invalidate</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed. ">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_writer.html#a73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed. ">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a901a51887d8339b159a6da2526c1970a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localDestroy </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a4ad8b7c842587d3a463bc6f42de13e0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localDestroyRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the whole region and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>Destroy cascades to all entries and subregions. After the destroy, this region object cannot be used any more. Any attempt to use this region object will get a <code>RegionDestroyedException</code> exception. The region destroy is not distributed to other caches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this call. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation; if this occurs some subregions may have already been successfully destroyed. </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#af033850fdf85930b496ee41d306e0b19" title="Invalidates this region. ">localInvalidateRegion</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6fd95f37c13a7cc49f5725feb782ba8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localInvalidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates the entry with the specified key in the local cache only, and provides a user-defined argument to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>. </p>
<p>Invalidate only removes the value from the entry, the key is kept intact. To completely remove the entry, destroy should be used. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the value to be invalidated </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. Should be serializable if passed to remote callback events </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">EntryNotFoundException</td><td>if this entry does not exist in this region locally </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a20d40355842f92cf63c8f64b1bb86aa0" title="Handles the event of an entry&#39;s value being invalidated. ">CacheListener::afterInvalidate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d3d87c6f98995d62340bcc425cfb85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localInvalidate </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="af033850fdf85930b496ee41d306e0b19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localInvalidateRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invalidates this region. </p>
<p>The invalidation will cascade to all the subregions and cached entries. After the <code>invalidateRegion</code> , the region and the entries in it still exist. In order to remove all the entries and the region, <code>destroyRegion</code> should be used. The region invalidate will not be distributed to other caches</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception; if this occurs some subregions may have already been successfully invalidated </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is no longer valid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a2b07a940ee17e375c45421e85b27a8ff" title="Destroys the whole region and provides a user-defined parameter object to any CacheWriter invoked in ...">destroyRegion</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#ad23f60ed056fb03912191092eef29a62" title="Handles the event of a region being invalidated. ">CacheListener::afterRegionInvalidate</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4326132930e9222a31ad9a1f56f1e5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a new value into an entry in this region with the specified key in the local cache only, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. If there is already an entry associated with the specified key in this region, the entry's previous value is overwritten. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key smart pointer associated with the value to be put into this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value to be put into the cache </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key or value is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if region no longer valid </td></tr>
    <tr><td class="paramname">OutOfMemoryException</td><td>if not enoough memory for the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a435c1b09500e647f7f71812a6a7d5b67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="ae8e22d89810f1c11f2fe8476b292b56c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="ae2a1111258f42b32da0809727a6d4954"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::localPut </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="aae5cd3bd2243440983f3fba8daed2aaa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key and value in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. Remove removes not only the value but also the key and entry from this region. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove. </td></tr>
    <tr><td class="paramname">value</td><td>the value of the entry to remove. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>the callback for user to pass in, default is NULLPTR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed. ">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_writer.html#a73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed. ">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a078430890a8f8e076e41517c00fbed1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a6be0122aac95491e758609aef1a3ed3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a7e39b02864f041d1e49614fa0e7e6f66"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a53889ab65787669cc437066f4199000f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::localRemoveEx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key in the local cache only, and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. Remove removes not only the value but also the key and entry from this region. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>the callback for user to pass in, default is NULLPTR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed. ">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_writer.html#a73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed. ">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa1bf71128966478b48e16c5dfe9ee29"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::localRemoveEx </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a327be04b1f16b21a84b654e62c8cb047"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::preserveSB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically increment reference count. </p>

</div>
</div>
<a class="anchor" id="aca7c7bf2eb5d466fa3f5dfa6f9b8d392"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::put </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a new value into an entry in this region with the specified key, providing a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. If there is already an entry associated with the specified key in this region, the entry's previous value is overwritten. The new put value is propogated to the java server to which it is connected with. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry.</p>
<p>If remote server put fails throwing back a <code>CacheServerException</code> or security exception, then local put is tried to rollback. However, if the entry has overflowed/evicted/expired then the rollback is aborted since it may be due to a more recent notification or update by another thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a key smart pointer associated with the value to be put into this region. </td></tr>
    <tr><td class="paramname">value</td><td>the value to be put into the cache </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key or value is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if region no longer valid </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
    <tr><td class="paramname">OutOfMemoryException</td><td>if not enoough memory for the value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1394ea4f20da5c42d52a5acd7aa62815"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::put </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a18ed32cff76c8fa62654bcc6a70e1ace"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::put </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="ab39f20f36b8dbb95c46aa19dd9b1d63e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::Region::put </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a73a7d08dccc68bbea42a0e27aee9cf2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::putAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_hash_map_of_cacheable.html">HashMapOfCacheable</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code>15</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Places a set of new values in this region with the specified keys given as a map of key/value pairs. </p>
<p>If there is already an entry associated with a specified key in this region, the entry's previous value is overwritten. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A hashmap containing key-value pairs </td></tr>
    <tr><td class="paramname">timeout</td><td>The time (in seconds) to wait for the response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483. Default is 15 (seconds). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>8.1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions. It is ignored if NULLPTR. It must be serializable if this operation is distributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If timeout parameter is greater than 2^31/1000, ie 2147483. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60c3e653c2b6634a2a27de668cf3f7d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">SelectResultsPtr</a> gemfire::Region::query </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="gf__base_8hpp.html#a3652aa8957738101aa9d01b236305604">DEFAULT_QUERY_RESPONSE_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the query on the server based on the predicate. </p>
<p>Valid only for a Native Client region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time (in seconds) to wait for the query response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If predicate is empty or timeout parameter is greater than 2^31/1000. </td></tr>
    <tr><td class="paramname">QueryException</td><td>if some query error occurred at the server. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
    <tr><td class="paramname">CacheClosedException</td><td>if the cache has been closed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the <a class="el" href="classgemfire_1_1_select_results.html" title="A SelectResults is obtained by executing a Query on the server. ">SelectResults</a> which can either be a <a class="el" href="classgemfire_1_1_result_set.html" title="A ResultSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">ResultSet</a> or a <a class="el" href="classgemfire_1_1_struct_set.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">StructSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a197c0b015e8fa9656ea520a0fbd57008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t gemfire::SharedBase::refCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the reference count </dd></dl>

</div>
</div>
<a class="anchor" id="a40219e26a13978054c203024af365f71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::registerAllKeys </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_shared_ptr.html">VectorOfCacheableKeyPtr</a>&#160;</td>
          <td class="paramname"><em>resultKeys</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>receiveValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers to get updates for all keys from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isDurable</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td class="paramname">resultKeys</td><td>If non-NULLPTR then all the keys on the server that got registered are returned. The vector is cleared at the start to discard any existing keys in the vector. </td></tr>
    <tr><td class="paramname">getInitialValues</td><td>true to populate the cache with values of all keys from the server </td></tr>
    <tr><td class="paramname">receiveValues</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">EntryNotFoundException</td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac068483783251bdcbedb3e4f7e5071dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::registerKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>receiveValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers an array of keys for getting updates from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the array of keys </td></tr>
    <tr><td class="paramname">isDurable</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td class="paramname">getInitialValues</td><td>true to populate the cache with values of the keys that were registered on the server </td></tr>
    <tr><td class="paramname">receiveValues</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If the array of keys is empty. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If already registered interest for all keys. </td></tr>
    <tr><td class="paramname">EntryNotFoundException</td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd438bc24e6007094a3833c7ddf7cab4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::registerRegex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isDurable</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_shared_ptr.html">VectorOfCacheableKeyPtr</a>&#160;</td>
          <td class="paramname"><em>resultKeys</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>getInitialValues</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>receiveValues</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a regular expression to match with keys to get updates from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>The regular expression string. </td></tr>
    <tr><td class="paramname">isDurable</td><td>flag to indicate whether this is a durable registration </td></tr>
    <tr><td class="paramname">resultKeys</td><td>If non-NULLPTR then the keys that match the regular expression on the server are returned. The vector is cleared at the start to discard any existing keys in the vector. </td></tr>
    <tr><td class="paramname">getInitialValues</td><td>true to populate the cache with values of the keys that were registered on the server </td></tr>
    <tr><td class="paramname">receiveValues</td><td>whether to act like notify-by-subscription is set</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If regex is empty. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If already registered interest for all keys. </td></tr>
    <tr><td class="paramname">EntryNotFoundException</td><td>If an exception occurs while obtaining values from server after register interest is complete. The actual cause of the exception can be obtained using <code>Exception::getCause</code>. If an application wants to undo the registration on server, or take some other steps for the incomplete cache population then this is the exception that should be caught. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a44da117cf90615f1302a5a70b5eb9d91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void gemfire::SharedBase::releaseSB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Atomically decrement reference count, the <a class="el" href="classgemfire_1_1_shared_base.html" title="This abstract base class is the base class of all user objects that have the shared capability of ref...">SharedBase</a> object is automatically deleted when its reference count goes to zero. </p>

</div>
</div>
<a class="anchor" id="a759e15064bcccf16e898a8de8502851e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key, value and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. remove removes not only the value, but also the key and entry from this region.</p>
<p>The remove is propogated to the Gemfire cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code>CacheServerException</code> or security exception, then the local entry is still removed.</p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove </td></tr>
    <tr><td class="paramname">value</td><td>the value of the key to remove, it can be NULLPTR. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if the operation timed out </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed. ">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_writer.html#a73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed. ">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3a82b5a6f2c680cdb220587ce526ce7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE , class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="af725edc4a00f5c6ba756dcb813fba9e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheablePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="acb922e6630e184e6a7b115ddaa423cd9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUETYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUETYPE &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="ad7fd371695f56106874541c17c27b6a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::remove </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing both key and value to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a54b325cd1c41cd75bdeb8e97b93312a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::removeAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all of the entries for the specified keys from this region. </p>
<p>The effect of this call is equivalent to that of calling <a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e">destroy</a> on this region once for each key in the specified collection. If an entry does not exist that key is skipped; EntryNotFoundException is not thrown. </p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entries. </p><dl class="section since"><dt>Since</dt><dd>8.1 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the keys to remove from this region. </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>an argument that is passed to the callback functions. It is ignored if NULLPTR. It must be serializable if this operation is distributed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If the array of keys is empty. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server while processing the request. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the given servers For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c49ed8cd8ed88625ccad3791416590c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool gemfire::Region::removeEx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">CacheableKeyPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>aCallbackArgument</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the entry with the specified key and provides a user-defined parameter object to any <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code> invoked in the process. </p>
<p>The same parameter is also passed to the <code><a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a></code> and <code><a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a></code>, if one is defined for this <code><a class="el" href="classgemfire_1_1_region.html" title="This class manages subregions and cached data. ">Region</a></code>, invoked in the process. remove removes not only the value, but also the key and entry from this region.</p>
<p>The remove is propogated to the Gemfire cache server to which it is connected with. If the destroy fails due to an exception on server throwing back <code>CacheServerException</code> or security exception, then the local entry is still removed.</p>
<p>Updates the <a class="el" href="classgemfire_1_1_cache_statistics.html#a05dc850f2147fbbef624a3bf547f35c7">CacheStatistics::getLastAccessedTime</a> and <a class="el" href="classgemfire_1_1_cache_statistics.html#ae23f8086eb31288029324a2e53556657">CacheStatistics::getLastModifiedTime</a> for this region and the entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key of the entry to remove </td></tr>
    <tr><td class="paramname">aCallbackArgument</td><td>a user-defined parameter to pass to callback events triggered by this method. Can be NULLPTR. If it is sent on the wire, it has to be <a class="el" href="classgemfire_1_1_serializable.html" title="This abstract base class is the superclass of all user objects in the cache that can be serialized...">Serializable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>if key is NULLPTR </td></tr>
    <tr><td class="paramname">CacheWriterException</td><td>if <a class="el" href="classgemfire_1_1_cache_writer.html" title="An application plug-in that can be installed on the region. ">CacheWriter</a> aborts the operation </td></tr>
    <tr><td class="paramname">CacheListenerException</td><td>if <a class="el" href="classgemfire_1_1_cache_listener.html" title="An application plug-in that can be installed on a region. ">CacheListener</a> throws an exception </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if the operation timed out </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>if the region is destroyed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean true if an entry(key, value)has been removed or false if an entry(key, value) has not been removed. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgemfire_1_1_region.html#a41dd235083a3f598869ff5331a2b194e" title="Destroys the entry with the specified key, and provides a user-defined parameter object to any CacheW...">destroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_listener.html#a3763979ce97a517290279a38c8955132" title="Handles the event of an entry being destroyed. ">CacheListener::afterDestroy</a> </dd>
<dd>
<a class="el" href="classgemfire_1_1_cache_writer.html#a73ca2d0f119df8e8098dd51bc29bc5c6" title="Called before an entry is destroyed. ">CacheWriter::beforeDestroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4022b73e01f4f22bcba6a5bbc9e12dcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEYTYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool gemfire::Region::removeEx </td>
          <td>(</td>
          <td class="paramtype">const KEYTYPE &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_shared_ptr.html">UserDataPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em> = <code>gemfire::NullSharedBase::s_instancePtr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method allowing key to be a const char*. </p>

</div>
</div>
<a class="anchor" id="a2aed8c623fb3cec5e5574348c268e581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classgemfire_1_1_shared_ptr.html">SerializablePtr</a> gemfire::Region::selectValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em> = <code><a class="el" href="gf__base_8hpp.html#a3652aa8957738101aa9d01b236305604">DEFAULT_QUERY_RESPONSE_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the query on the server based on the predicate and returns a single result value. </p>
<p>Valid only for a Native Client region. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>The query predicate (just the WHERE clause) or the entire query to execute. </td></tr>
    <tr><td class="paramname">timeout</td><td>The time (in seconds) to wait for the response, optional. This should be less than or equal to 2^31/1000 i.e. 2147483. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If predicate is empty or timeout parameter is greater than 2^31/1000. </td></tr>
    <tr><td class="paramname">QueryException</td><td>if some query error occurred at the server, or more than one result items are available. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if a server connection error occurs. For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
    <tr><td class="paramname">CacheClosedException</td><td>if the cache has been closed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer to the single <a class="el" href="classgemfire_1_1_result_set.html" title="A ResultSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">ResultSet</a> or <a class="el" href="classgemfire_1_1_struct_set.html" title="A StructSet may be obtained after executing a Query which is obtained from a QueryService which in tu...">StructSet</a> item, or NULLPTR of no results are available. </dd></dl>

</div>
</div>
<a class="anchor" id="ab0429277fb24eb3e7401dae91a699155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::serverKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the set of keys defined in the server process associated to this client and region. </p>
<p>If a server has the region defined as a mirror, then this will be the entire keyset for the region across all PEER in the distributed system. The vector v will contain only the server keys. Any prior contents in the vector will be removed. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Gemfire cache server. Only for Native Client regions. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">MessageExcepton</td><td>If the message received from server could not be handled. This will be the case when an unregistered typeId is received in the reply or reply is not well formed. More information can be found in the log. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if there is a timeout getting the keys </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>if the member type is not CLIENT or region is not a native client one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5936a627a93153f6d6be7af1c41a4b49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t gemfire::Region::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of region. </p>
<p>For native client regions, this will give the number of entries in the local cache and not on the servers. </p>

</div>
</div>
<a class="anchor" id="aaad82433371c15d619b88baa8b35903e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::subregions </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_vector_t.html">VectorOfRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>sr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populates the passed in VectorOfRegion with subregions of the current region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">recursive</td><td>determines whether the method recursively fills in subregions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sr</td><td>subregions </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">RegionDestroyedException</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93608329f29a824fa78fa0ecc20de9b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::unregisterAllKeys </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers to get updates for all keys from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalStateException</td><td>If not previously registered all keys. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ed1c18d8b7ed87f89a26e8199b09f32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::unregisterKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgemfire_1_1_vector_of_cacheable_key.html">VectorOfCacheableKey</a> &amp;&#160;</td>
          <td class="paramname"><em>keys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters an array of keys to stop getting updates for them. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>the array of keys</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If the array of keys is empty. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If no keys were previously registered. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21fdcf25dc377ca43544ee1cacd241cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::unregisterRegex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>regex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unregisters a regular expression to stop getting updates for keys from the server. </p>
<p>Valid only for a Native Client region when client notification ( <a class="el" href="">AttributesFactory::setClientNotification</a> ) is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regex</td><td>The regular expression string.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IllegalArgumentException</td><td>If regex is empty. </td></tr>
    <tr><td class="paramname">IllegalStateException</td><td>If not previously registered this regular expression string. </td></tr>
    <tr><td class="paramname">UnsupportedOperationException</td><td>If the region is not a Native Client region or <a class="el" href="">AttributesFactory::setClientNotification</a> is false. </td></tr>
    <tr><td class="paramname">CacheServerException</td><td>If an exception is received from the Java cache server. </td></tr>
    <tr><td class="paramname">NotConnectedException</td><td>if it is not connected to the cache because the client cannot establish usable connections to any of the servers given to it For pools configured with locators, if no locators are available, the cause of NotConnectedException is set to NoAvailableLocatorsException. </td></tr>
    <tr><td class="paramname">RegionDestroyedException</td><td>If region destroy is pending. </td></tr>
    <tr><td class="paramname">UnknownException</td><td>For other exceptions. </td></tr>
    <tr><td class="paramname">TimeoutException</td><td>if operation timed out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d25cce2f2fcff0ba37e3f8f43c345b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void gemfire::Region::values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgemfire_1_1_vector_of_cacheable.html">VectorOfCacheable</a> &amp;&#160;</td>
          <td class="paramname"><em>vc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all values in the local process for this region. </p>
<p>No value is included for entries that are invalidated. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<HR><address style="align: right;"><small>GemFire C++ Cache API Documentation</small></address>
